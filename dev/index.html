<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ComplexRegions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ComplexRegions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Abstract-types-1">Abstract types</a></li><li><a class="toctext" href="#Curve,-Path,-and-Region-1">Curve, Path, and Region</a></li><li><a class="toctext" href="#Tolerance-1">Tolerance</a></li><li><a class="toctext" href="#global_defaults-1">Global defaults</a></li></ul></li><li><a class="toctext" href="curves/">Curves</a></li><li><a class="toctext" href="paths/">Paths</a></li><li><a class="toctext" href="polygons/">Polygons</a></li><li><a class="toctext" href="intersections/">Intersections</a></li><li><a class="toctext" href="regions/">Regions</a></li><li><a class="toctext" href="mobius/">Möbius</a></li><li><a class="toctext" href="api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/complexvariables/ComplexRegions.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ComplexRegions-1" href="#ComplexRegions-1">ComplexRegions</a></h1><div></div><p>This package provides types and methods that are useful for working with curves and regions in the (extended) complex plane.</p><p>Most functionality is provided through Julia types (roughly equivalent to classes in an object-oriented language). Per Julia conventions, these are all capitalized. You use these capitalized names to create values of the type; e.g., <a href="curves/#Segment-1">Segment</a> and <a href="curves/#Circle-1">Circle</a>.</p><p>Other functions (methods, in Julia terms) may create values of these types, but since they are not distinct types themselves, they are not capitalized. For example, the <a href="api/#ComplexRegions.rectangle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>rectangle</code></a> method creates a <a href="polygons/#Polygon-1">Polygon</a>.</p><p>The methods in this package should work not only with the built-in <code>Complex</code> type, but also with the <code>Polar</code> and <code>Spherical</code> types from the <a href="https://complexvariables.github.io/ComplexValues.jl/stable/"><code>ComplexValues</code></a> package, which it re-exports.</p><h2><a class="nav-anchor" id="Abstract-types-1" href="#Abstract-types-1">Abstract types</a></h2><p>All <code>abstract</code> types have names starting with <code>Abstract</code>. You probably won&#39;t encounter them unless you want to extend the provided functionality.</p><p>An abstract type cannot itself be instantiated as a value. They serve as supertypes that collect common-denominator functionality, much like an <em>interface</em> in other languages. For example, any <code>AbstractCurve</code> is supposed to provide functions for finding points, tangents, and normals along the curve. Specific subtypes such as a <a href="curves/#Ray-1">Ray</a> or <a href="curves/#Arc-1">Arc</a> provide additional specialized functionalities appropriate to the subtypes.</p><h2><a class="nav-anchor" id="Curve,-Path,-and-Region-1" href="#Curve,-Path,-and-Region-1">Curve, Path, and Region</a></h2><p>A <strong>curve</strong> is meant to be a smooth, non-self-intersecting curve in the extended complex plane. There is a generic <a href="curves/#Curve-1">Curve</a> type that requires you to specify an explicit parameterization that is not checked for smoothness or even continuity. Implementations are given for more specific types of curve.</p><p>A <strong>path</strong> is a piecewise-continuous complex-valued path. In practice a <a href="paths/#Path-1">Path</a> can be specified as an array of curves. The path is checked for continuity at creation time. The most important provided specific path types are <a href="polygons/#Polygon-1">Polygon</a> and <a href="polygons/#CircularPolygon-1">CircularPolygon</a>.</p><p>Both curves and paths have <strong>closed</strong> variants. These are additionally checked that the initial and final points are the same.</p><p>One atypical aspect of curves and paths, even &quot;closed&quot; ones, is that they lie in the <em>extended</em> or compactified complex plane and thus may be unbounded. For instance, a line in the plane may be interpreted as a circle on the Riemann sphere, and is thus a &quot;closed&quot; curve passing through infinity.</p><p>A <strong>region</strong> is an open region in the extended plane bounded by a closed curve or path.</p><p>Some examples:</p><pre><code class="language-julia-repl">julia&gt; ℓ = Line(1/2,1/2+1im)  # line through 0.5 and 0.5+1i
Line{Complex{Float64}} in the complex plane:
   through (0.5 + 0.0im) parallel to (0.0 + 1.0im)

julia&gt; c = 1 / ℓ          # a circle
Circle{Complex{Float64}} in the complex plane:
   centered at (1.0 + 0.0im) with radius 1.0, negatively oriented

julia&gt; intersect(ℓ,c)
2-element Array{Complex{Float64},1}:
 0.5 + 0.8660254037844386im
 0.5 - 0.8660254037844386im

julia&gt; plot(ℓ); plot!(c)
Plot{Plots.GRBackend() n=2}</code></pre><p><img src="line_circle.svg" alt="line and circle"/></p><pre><code class="language-julia-repl">julia&gt; plot(Spherical(ℓ)); plot!(Spherical(c))
Plot{Plots.GRBackend() n=40}</code></pre><p><img src="line_circle_sphere.svg" alt="line and circle on Riemann sphere"/></p><pre><code class="language-julia-repl">julia&gt; reflect(-1,c)       # reflection of a point through the circle
0.5 + 0.0im

julia&gt; plot(interior(ℓ))   # plot a half-plane
Plot{Plots.GRBackend() n=1}</code></pre><p><img src="halfplane.svg" alt="half-plan"/></p><pre><code class="language-julia-repl">julia&gt; h = n_gon(7)
Polygon with 7 vertices:
   1.0 + 0.0im, interior angle 0.7142857142857143⋅π
   0.6234898018587336 + 0.7818314824680298im, interior angle 0.7142857142857143⋅π
   -0.22252093395631434 + 0.9749279121818236im, interior angle 0.7142857142857143⋅π
   -0.900968867902419 + 0.43388373911755823im, interior angle 0.7142857142857143⋅π
   -0.9009688679024191 - 0.433883739117558im, interior angle 0.7142857142857143⋅π
   -0.2225209339563146 - 0.9749279121818236im, interior angle 0.7142857142857143⋅π
   0.6234898018587334 - 0.7818314824680299im, interior angle 0.7142857142857143⋅π

julia&gt; plot(h);

julia&gt; for k in 1:7
       	z = exp(k*2im*π/20)
       	plot!(z*h - 0.5k - 0.1im*k^2)
       end</code></pre><p><img src="heptagons.svg" alt="heptagons"/></p><pre><code class="language-julia-repl">julia&gt; p = Polygon([0,-1im,(0,0),1im,(pi,pi)])      # channel with a step
Polygon with 5 vertices:
   0.0 + 0.0im, interior angle 1.5⋅π
   0.0 - 1.0im, interior angle 0.5⋅π
   Inf + 0.0im, interior angle 0.0⋅π
   0.0 + 1.0im, interior angle 1.0⋅π
   Inf + 0.0im, interior angle 0.0⋅π

julia&gt; plot(interior(p))
Plot{Plots.GRBackend() n=1}</code></pre><p><img src="channel.png" alt="channel with step"/></p><h2><a class="nav-anchor" id="Tolerance-1" href="#Tolerance-1">Tolerance</a></h2><p>Boundaries and endpoints are not well-posed ideas in floating-point, since an arbitrarily small perturbation to a value can move a point on or off of them. Thus many concepts in the package such as intersection or continuity are checked only up to a small tolerance. This value can be set on a per-call basis, or by using <a href="#global_defaults-1">global defaults</a>.</p><h2><a class="nav-anchor" id="global_defaults-1" href="#global_defaults-1">Global defaults</a></h2><p>For work at the REPL, it&#39;s convenient to be able to set an influential parameter just once rather than in multiple calls. This mechanism is provided via <a href="api/#ComplexRegions.default-Tuple{}"><code>ComplexRegions.default</code></a>. You can see all the default parameters and values as follows:</p><pre><code class="language-julia-repl">julia&gt; ComplexRegions.default()
Dict{Symbol,Float64} with 1 entry:
  :tol =&gt; 1.0e-12</code></pre><p>Changing them is done with the same function:</p><pre><code class="language-julia-repl">julia&gt; ComplexRegions.default(tol=1e-8)
[ Info: Default value of `tol` set to 1.0e-8.</code></pre><p>Be advised that this type of &quot;stateful&quot; computing brings some subtle undesirable consequences. For example, if the global default <code>tol</code> is changed in a future release of the package, existing code could give different results when testing for interior points. If maximum reproducibility is a concern, you should develop the habit of setting all defaults yourself at the beginning of your code.</p><footer><hr/><a class="next" href="curves/"><span class="direction">Next</span><span class="title">Curves</span></a></footer></article></body></html>
