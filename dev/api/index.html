<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · ComplexRegions.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ComplexRegions.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../paths/">Paths</a></li><li><a class="tocitem" href="../polygons/">Polygons</a></li><li><a class="tocitem" href="../intersections/">Intersections</a></li><li><a class="tocitem" href="../regions/">Regions</a></li><li><a class="tocitem" href="../mobius/">Möbius</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/complexvariables/ComplexRegions.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Annulus" href="#ComplexRegions.Annulus"><code>ComplexRegions.Annulus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Annulus</code></pre><p>Representation of the region between two circles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L216-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Annulus" href="#ComplexRegions.Annulus"><code>ComplexRegions.Annulus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Annulus(radouter,radinner)
Annulus(radouter,radinner,center)</code></pre><p>Construct a concentric annulus of outer radius <code>radouter</code> and inner radius <code>radinner</code> centered at <code>center</code>. If the center is not given, the origin is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Arc" href="#ComplexRegions.Arc"><code>ComplexRegions.Arc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Arc{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Arc</code> type is parameterized according to the common type of its complex input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Arc-Union{Tuple{T}, Tuple{Circle{T}, Real, Real}} where T&lt;:(Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat)" href="#ComplexRegions.Arc-Union{Tuple{T}, Tuple{Circle{T}, Real, Real}} where T&lt;:(Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat)"><code>ComplexRegions.Arc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Arc(C,start,delta)</code></pre><p>Consruct an arc that is the part of the Circle <code>C</code> starting at parameter value <code>start</code> and ending at <code>start+delta</code>. The values are expressed in terms of fractions of a complete circle. The <code>start</code> value should be in [0,1), and <code>delta</code> should be in [-1,1].</p><pre><code class="nohighlight hljs">Arc(a,b,c)</code></pre><p>Construct the arc starting at point <code>a</code>, passing through <code>b</code>, and ending at <code>c</code>. If the three points are collinear, a <code>Segment</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Circle" href="#ComplexRegions.Circle"><code>ComplexRegions.Circle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circle(zc,r,ccw=true)</code></pre><p>Construct the circle with given center <code>zc</code>, radius <code>r</code>, and orientation (defaults to counterclockwise).</p><pre><code class="nohighlight hljs">Circle(a,b,c)</code></pre><p>Construct the circle passing through the given three numbers. Orientation is determined so that the values are visited in the given order. If the three points are collinear (including when one of the given values is infinite), a <code>Line</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Circle" href="#ComplexRegions.Circle"><code>ComplexRegions.Circle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Circle{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Circle</code> type is parameterized according to the common type of its complex input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.CircularPolygon" href="#ComplexRegions.CircularPolygon"><code>ComplexRegions.CircularPolygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) CircularPolygon</code></pre><p>Type for closed paths consisting entirely of arcs, segments, and rays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.CircularPolygon-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.CircularPolygon-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.CircularPolygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CircularPolygon(p::AbstractPath; tol=&lt;default&gt;)
CircularPolygon(p::AbstractVector; tol=&lt;default&gt;)</code></pre><p>Construct a circular polygon from a (possibly closed) path, or from a vector of curves. The <code>tol</code> parameter is a tolerance used when checking continuity and closedness of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ClosedCurve" href="#ComplexRegions.ClosedCurve"><code>ComplexRegions.ClosedCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClosedCurve(f; tol=&lt;default&gt;)
ClosedCurve(f,a,b; tol=&lt;default)</code></pre><p>Construct a <code>ClosedCurve</code> object from the complex-valued function <code>point</code> accepting an argument in the interval [0,1]. The constructor checks whether <code>f(0)≈f(1)</code> to tolerance <code>tol</code>. If <code>a</code> and <code>b</code> are given, they are the limits of the parameter in the call to the supplied <code>f</code>. However, the resulting object will be defined on [0,1], which is internally scaled to [a,b].</p><pre><code class="nohighlight hljs">ClosedCurve(f,df[,a,b]; tol=&lt;default&gt;)</code></pre><p>Construct a closed curve with point location and tangent given by the complex-valued functions <code>f</code> and <code>df</code>, respectively, optionally with given limits on the parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ClosedCurve" href="#ComplexRegions.ClosedCurve"><code>ComplexRegions.ClosedCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(type) Smooth closed curve defined by an explicit function of a real paramerter in [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L133-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ClosedPath" href="#ComplexRegions.ClosedPath"><code>ComplexRegions.ClosedPath</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) ClosedPath</code></pre><p>Generic implementation of an <code>AbstractClosedPath</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L293-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ClosedPath-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexRegions.ClosedPath-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexRegions.ClosedPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ClosedPath(c::AbstractVector; tol=&lt;default&gt;)
ClosedPath(P::Path; tol=&lt;default&gt;)</code></pre><p>Given a vector <code>c</code> of curves, or an existing path, construct a closed path. The path is checked for continuity (to tolerance <code>tol</code>) at all of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ConnectedRegion" href="#ComplexRegions.ConnectedRegion"><code>ComplexRegions.ConnectedRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) ConnectedRegion{N}</code></pre><p>Representation of a <code>N</code>-connected region in the extended complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L144-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ConnectedRegion-Tuple{Any, Any}" href="#ComplexRegions.ConnectedRegion-Tuple{Any, Any}"><code>ComplexRegions.ConnectedRegion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConnectedRegion(outer,inner)</code></pre><p>Construct an open connected region by specifying its boundary components. The <code>outer</code> boundary could be <code>nothing</code> or a closed curve or path. The <code>inner</code> boundary should be a vector of one or more nonintersecting closed curves or paths. The defined region is interior to the outer boundary and exterior to all the components of the inner boundary, regardless of the orientations of the given curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L174-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Curve" href="#ComplexRegions.Curve"><code>ComplexRegions.Curve</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(type) Smooth curve defined by an explicit function of a real paramerter in [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L94-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Curve-Tuple{Any}" href="#ComplexRegions.Curve-Tuple{Any}"><code>ComplexRegions.Curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Curve(f)
Curve(f,a,b)</code></pre><p>Construct a <code>Curve</code> object from the complex-valued function <code>f</code> accepting an argument in the interval [0,1]. If <code>a</code> and <code>b</code> are given, they are the limits of the parameter in the call to the supplied <code>f</code>. However, the resulting object will be defined on [0,1], which is internally scaled to [a,b].</p><pre><code class="nohighlight hljs">Curve(f,df[,a,b])</code></pre><p>Construct a curve with point location and tangent given by the complex-valued functions <code>f</code> and <code>df</code>, respectively, optionally with given limits on the parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Line" href="#ComplexRegions.Line"><code>ComplexRegions.Line</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Line{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Line</code> type is parameterized according to the common type of its complex input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Line-Tuple{Number, Number}" href="#ComplexRegions.Line-Tuple{Number, Number}"><code>ComplexRegions.Line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Line(a,b)</code></pre><p>Construct the line passing through the two given points.</p><pre><code class="nohighlight hljs">Line(a,direction=z)</code></pre><p>Construct the line through the given point and parallel to the complex sign of the given <code>direction</code> value. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius" href="#ComplexRegions.Möbius"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Möbius</code></pre><p>Representation of a Möbius or bilinear transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-NTuple{4, Number}" href="#ComplexRegions.Möbius-NTuple{4, Number}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Möbius(a,b,c,d)</code></pre><p>Construct the <code>Möbius</code> map <span>$z ↦ (az+b)/(cz+d)$</span> by giving its coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{AbstractMatrix}" href="#ComplexRegions.Möbius-Tuple{AbstractMatrix}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Möbius(A::AbstractMatrix)</code></pre><p>Construct the <code>Möbius</code> map <span>$z ↦ (az+b)/(cz+d)$</span> by giving a matrix <code>A==[a b;c d]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{AbstractVector, AbstractVector}" href="#ComplexRegions.Möbius-Tuple{AbstractVector, AbstractVector}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Möbius(z::AbstractVector,w::AbstractVector)</code></pre><p>Construct the <code>Möbius</code> map that transforms the points <code>z[k]</code> to <code>w[k]</code> for k=1,2,3. Values of <code>Inf</code> are permitted in both vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Number}" href="#ComplexRegions.Möbius-Tuple{Number}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(z::Number)</code></pre><p>Evaluate the <code>Möbius</code> map <code>f</code> at a real or complex value <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Arc, Segment}}" href="#ComplexRegions.Möbius-Tuple{Union{Arc, Segment}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(C::Union{Arc,Segment})</code></pre><p>Find the image of the arc or segment <code>C</code> under the <code>Möbius</code> map <code>f</code>. The result is also either an <code>Arc</code> or a <code>Segment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Circle, Line}, Union{Circle, Line}}" href="#ComplexRegions.Möbius-Tuple{Union{Circle, Line}, Union{Circle, Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Möbius(C1,C2)</code></pre><p>Construct a <code>Möbius</code> map that transforms the curve <code>C1</code> to <code>C2</code>. Both curves must be either a <code>Line</code> or <code>Circle</code>. (These maps are not uniquely determined.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Circle, Line}}" href="#ComplexRegions.Möbius-Tuple{Union{Circle, Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(C::Union{Circle,Line})</code></pre><p>Find the image of the circle or line <code>C</code> under the <code>Möbius</code> map <code>f</code>. The result is also either a <code>Circle</code> or a <code>Line</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L79-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{ComplexRegions.ExteriorSimplyConnectedRegion{&lt;:Circle}, ComplexRegions.InteriorSimplyConnectedRegion{T} where T&lt;:Circle, Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Line}}" href="#ComplexRegions.Möbius-Tuple{Union{ComplexRegions.ExteriorSimplyConnectedRegion{&lt;:Circle}, ComplexRegions.InteriorSimplyConnectedRegion{T} where T&lt;:Circle, Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f(R::Union{AbstractDisk,AbstractHalfplane})</code></pre><p>If <code>R</code> is an <code>AbstractDisk</code> or an <code>AbstractHalfplane</code>, find its image under the <code>Möbius</code> map <code>f</code>. The result is also either an <code>AbstractDisk</code> or an <code>AbstractHalfplane</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = Möbius(Line(-1,1),Circle(0,1))
Möbius transformation:

   (1.0 + 0.9999999999999999im) z + (3.666666666666666 - 1.666666666666667im)
   ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
   (1.0 + 0.9999999999999999im) z + (-1.666666666666666 + 3.6666666666666665im)

julia&gt; f(upperhalfplane)
Disk interior to:
   Circle(-5.55112e-17+2.22045e-16im,1.0)

julia&gt; isapprox(ans,unitdisk)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L90-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Path" href="#ComplexRegions.Path"><code>ComplexRegions.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Path</code></pre><p>Generic implementation of an <code>AbstractPath</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L264-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Path-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexRegions.Path-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexRegions.Path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Path(c::AbstractVector; tol=&lt;default&gt;)</code></pre><p>Given a vector <code>c</code> of curves, construct a path. The path is checked for continuity (to tolerance <code>tol</code>) at the interior vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L278-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Polygon" href="#ComplexRegions.Polygon"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Polygon</code></pre><p>Type for closed paths consisting entirely of segments and rays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Polygon-Tuple{AbstractVector}" href="#ComplexRegions.Polygon-Tuple{AbstractVector}"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Polygon(v::AbstractVector)</code></pre><p>Construct a polygon from a vector of its vertices. Each element of <code>v</code> should be either a finite vertex, or a tuple of two angles that indicate the angles of two rays incident to an infinite vertex: one &quot;to&quot; infinity, and a second &quot;from&quot; infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Polygon-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.Polygon-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Polygon(p::AbstractPath; tol=&lt;default&gt;)
Polygon(p::AbstractVector{T&lt;:AbstractCurve}; tol=&lt;default&gt;)</code></pre><p>Construct a polygon from a (possibly closed) path, or from a vector of curves. The <code>tol</code> parameter is a tolerance used when checking continuity and closedness of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Ray" href="#ComplexRegions.Ray"><code>ComplexRegions.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ray(a,θ,reverse=false)</code></pre><p>Construct the ray starting at <code>a</code> and extending to infinity at the angle <code>θ</code>. If <code>reverse</code> is true, the ray is considered to extend from infinity to <code>a</code> at angle <code>-θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Ray" href="#ComplexRegions.Ray"><code>ComplexRegions.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Ray{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Ray</code> type is parameterized according to the common type of its complex input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.RegionIntersection" href="#ComplexRegions.RegionIntersection"><code>ComplexRegions.RegionIntersection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) RegionIntersection</code></pre><p>Representation of the intersection of two regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.RegionUnion" href="#ComplexRegions.RegionUnion"><code>ComplexRegions.RegionUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) RegionUnion</code></pre><p>Representation of the union of two regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Segment" href="#ComplexRegions.Segment"><code>ComplexRegions.Segment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(type) Segment{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Segment</code> type is parameterized according to the common type of its complex input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.Segment-Tuple{Number, Number}" href="#ComplexRegions.Segment-Tuple{Number, Number}"><code>ComplexRegions.Segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Segment(a,b)</code></pre><p>Consruct a segment that starts at value <code>a</code> and ends at <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexValues.Polar-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexValues.Polar-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexValues.Polar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Polar(::AbstractCurve)</code></pre><p>Interpret a curve as having points of type Polar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexValues.Spherical-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexValues.Spherical-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexValues.Spherical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Spherical(::AbstractCurve)</code></pre><p>Interpret a curve as having points of type Spherical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L11-L14">source</a></section></article><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:!-Tuple{ComplexRegions.InteriorSimplyConnectedRegion}" href="#Base.:!-Tuple{ComplexRegions.InteriorSimplyConnectedRegion}"><code>Base.:!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!(R::SimplyConnectedRegion)</code></pre><p>Compute the region complementary to <code>R</code>. This is not quite set complementation, as neither region includes its boundary. The complement is always simply connected in the extended plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{Möbius, Möbius}" href="#Base.:∘-Tuple{Möbius, Möbius}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∘(f::Möbius,g::Möbius)</code></pre><p>Compose two <code>Möbius</code> transformations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L118-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.conj-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(X)</code></pre><p>Construct the complex conjugate of curve, path, or region <code>X</code>. (Reverses the orientation of a curve or path.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L67-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Number, ComplexRegions.AbstractRegion}" href="#Base.in-Tuple{Number, ComplexRegions.AbstractRegion}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(z::Number,R::AbstractRegion;tol=&lt;default&gt;)
z ∈ R   (type &quot;\in&quot; followed by tab)</code></pre><p>True if <code>z</code> is in the region <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intersect(c1::AbstractCurve,c2::AbstractCurve; tol=&lt;default&gt;)</code></pre><p>Find the intersection(s) of two curves. The result could be a vector of zero or more values, or a curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/intersections.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Tuple{ComplexRegions.AbstractRegion, ComplexRegions.AbstractRegion}" href="#Base.intersect-Tuple{ComplexRegions.AbstractRegion, ComplexRegions.AbstractRegion}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(R1::AbstractRegion,R2::AbstractRegion)
R1 ∩ R2    (type &quot;\cap&quot; followed by tab key)</code></pre><p>Create the region that is the intersection of <code>R1</code> and <code>R2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Arc}" href="#Base.inv-Tuple{Arc}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(A)</code></pre><p>Invert the arc <code>A</code> through the origin. In general the inverse is an <code>Arc</code>, though the result is a <code>Segment</code> if the arc&#39;s circle passes through the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Circle}" href="#Base.inv-Tuple{Circle}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(C)</code></pre><p>Invert the circle <code>C</code> through the origin. In general the inverse is a <code>Circle</code>, though the result is a <code>Line</code> if <code>C</code> passes through the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L91-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Line}" href="#Base.inv-Tuple{Line}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(L)</code></pre><p>Invert a line <code>L</code> through the origin. In general the inverse is a <code>Circle</code> through the inverse of any three points on the line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Möbius}" href="#Base.inv-Tuple{Möbius}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(f::Möbius)</code></pre><p>Find the inverse of a <code>Möbius</code> transformation. This is the functional inverse, not 1/f(z).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/mobius.jl#L112-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Ray}" href="#Base.inv-Tuple{Ray}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(R)</code></pre><p>Invert the ray <code>R</code> through the origin. In general the inverse is an <code>Arc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Segment}" href="#Base.inv-Tuple{Segment}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(S)</code></pre><p>Invert the segment <code>S</code> through the origin. In general the inverse is an <code>Arc</code>, though the result is a <code>Segment</code> if <code>S</code> would pass through the origin when extended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.inv-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(X)</code></pre><p>Invert a curve, path, or region pointwise.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L62-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Arc, Arc}" href="#Base.isapprox-Tuple{Arc, Arc}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(A1::Arc,A2::Arc; tol=&lt;default&gt;)
A1 ≈ A2</code></pre><p>Determine if <code>A1</code> and <code>A2</code> represent the same arc, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Circle, Circle}" href="#Base.isapprox-Tuple{Circle, Circle}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(C1::Circle,C2::Circle; tol=&lt;default&gt;)
C1 ≈ C2</code></pre><p>Determine if <code>C1</code> and <code>C2</code> represent the same circle, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{ComplexRegions.AbstractPath, ComplexRegions.AbstractPath}" href="#Base.isapprox-Tuple{ComplexRegions.AbstractPath, ComplexRegions.AbstractPath}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(P1::AbstractPath,R2::AbstractPath; tol=&lt;default&gt;)
P1 ≈ P2       (type &quot;\approx&quot; followed by tab key)</code></pre><p>Determine whether <code>P1</code> and <code>P2</code> represent the same path, up to tolerance <code>tol</code>, irrespective of the parameterization of its curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Line, Line}" href="#Base.isapprox-Tuple{Line, Line}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(L1::Line,L2::Line; tol=&lt;default&gt;)
L1 ≈ L2</code></pre><p>Determine if <code>L1</code> and <code>L2</code> represent the same line, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Ray, Ray}" href="#Base.isapprox-Tuple{Ray, Ray}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(R1::Ray,R2::Ray; tol=&lt;default&gt;)
R1 ≈ R2</code></pre><p>Determine if <code>R1</code> and <code>R2</code> represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Segment, Segment}" href="#Base.isapprox-Tuple{Segment, Segment}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(S1::Segment,S2::Segment; tol=&lt;default&gt;)
S1 ≈ S2</code></pre><p>Determine if <code>S1</code> and <code>S2</code> represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{S, T}} where {S, T&lt;:(Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath})}" href="#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{S, T}} where {S, T&lt;:(Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath})}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(R1::SimplyConnectedRegion,R2::SimplyConnectedRegion; tol=&lt;default&gt;)</code></pre><p>Determine whether <code>R1</code> and <code>R2</code> represent the same region, up to tolerance <code>tol</code>. Equivalently, determine whether their boundaries are the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractCurve}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractCurve}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfinite(C::AbstractCurve)</code></pre><p>Return <code>true</code> if the curve is bounded in the complex plane (i.e., does not pass through infinity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractPath}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractPath}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfinite(P::AbstractPath)</code></pre><p>Return <code>true</code> if the path is bounded in the complex plane (i.e., does not pass through infinity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractRegion}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractRegion}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfinite(R::AbstractRegion)</code></pre><p>Return <code>true</code> if the region is bounded in the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}" href="#Base.reverse-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(X)</code></pre><p>Construct a curve or path identical to <code>X</code> except with opposite direction of parameterization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.truncate-Tuple{Union{CircularPolygon, Polygon}, Circle}" href="#Base.truncate-Tuple{Union{CircularPolygon, Polygon}, Circle}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(P::Union{CircularPolygon,Polygon},C::Circle)</code></pre><p>Compute a trucated form of the polygon by replacing each pair of rays incident at infinity with two segments connected by an arc along the given circle. This is <em>not</em> a true clipping of the polygon, as finite sides are not altered. The result is either a CircularPolygon or the original <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L192-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.truncate-Tuple{Union{CircularPolygon, Polygon}}" href="#Base.truncate-Tuple{Union{CircularPolygon, Polygon}}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(P::Union{CircularPolygon,Polygon})</code></pre><p>Apply <code>truncate</code> to <code>P</code> using a circle that is centered at the centroid of its finite vertices, and a radius twice the maximum from the centroid to the finite vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L183-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Tuple{ComplexRegions.AbstractRegion, ComplexRegions.AbstractRegion}" href="#Base.union-Tuple{ComplexRegions.AbstractRegion, ComplexRegions.AbstractRegion}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union(R1::AbstractRegion,R2::AbstractRegion)
R1 ∪ R2    (type &quot;\cup&quot; followed by tab key)</code></pre><p>Create the region that is the union of <code>R1</code> and <code>R2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.angles-Tuple{ComplexRegions.AbstractClosedPath}" href="#ComplexRegions.angles-Tuple{ComplexRegions.AbstractClosedPath}"><code>ComplexRegions.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(P::AbstractPath)</code></pre><p>Return a vecrtor of the interior angles at the vertices of the path <code>P</code>. The length is one greater than the number of curves in <code>P</code>, and the first and last values are <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L219-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.angles-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.angles-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(P::AbstractPath)</code></pre><p>Return a vecrtor of the interior angles at the vertices of the path <code>P</code>. The length is one greater than the number of curves in <code>P</code>, and the first and last values are <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L114-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.angles-Tuple{Polygon}" href="#ComplexRegions.angles-Tuple{Polygon}"><code>ComplexRegions.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(P::Polygon)</code></pre><p>Compute a vector of interior angles at the vertices of the polygon <code>P</code>. At a finite vertex these lie in (0,2π]; at an infinite vertex, the angle is in [-2π,0].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L225-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arclength-Tuple{Path}" href="#ComplexRegions.arclength-Tuple{Path}"><code>ComplexRegions.arclength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arclength(P::Path)</code></pre><p>Compute the arclength of the path <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L285-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arclength-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}" href="#ComplexRegions.arclength-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}"><code>ComplexRegions.arclength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arclength(X)</code></pre><p>Fetch or compute the arc length of the curve or path <code>X</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; ellipse = ClosedCurve( t-&gt;cos(t)+2im*sin(t), 0,2π );
julia&gt; arclength(ellipse)  # good to about 10 digits
9.688448219981513</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L80-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Arc, Number}" href="#ComplexRegions.arg-Tuple{Arc, Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arg(A::Arc,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>A(t)==z</code> is true.</p><p>This gives undefined results if <code>z</code> is not actually on the arc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Circle, Number}" href="#ComplexRegions.arg-Tuple{Circle, Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arg(C::Circle,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>C(t)==z</code> is true.</p><p>This gives undefined results if <code>z</code> is not actually on the circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Line, Number}" href="#ComplexRegions.arg-Tuple{Line, Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arg(L::Line,z)</code></pre><p>Find a parameter argument <code>t</code> such that <code>L(t)==z</code> is true. For an infinite <code>z</code>, return zero (but note that <code>L(1)</code> is also infinity).</p><p>This gives undefined results if <code>z</code> is not actually on the line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Ray, Number}" href="#ComplexRegions.arg-Tuple{Ray, Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arg(R::Ray,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>R(t)==z</code> is true.</p><p>This gives undefined results if <code>z</code> is not actually on the ray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Segment, Number}" href="#ComplexRegions.arg-Tuple{Segment, Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arg(S::Segment,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>S(t)==z</code> is true.</p><p>This gives undefined results if <code>z</code> is not actually on the segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.between-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.between-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">between(outer,inner)</code></pre><p>Construct the region interior to the closed curve or path <code>outer</code> and interior to <code>inner</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/regions.jl#L199-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, Arc}" href="#ComplexRegions.closest-Tuple{Number, Arc}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,A::Arc)</code></pre><p>Find the point on arc <code>A</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, Circle}" href="#ComplexRegions.closest-Tuple{Number, Circle}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,C::Circle)</code></pre><p>Find the point on circle <code>C</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L126-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, ComplexRegions.AbstractPath}" href="#ComplexRegions.closest-Tuple{Number, ComplexRegions.AbstractPath}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,P::AbstractPath)</code></pre><p>Find the point on the path <code>P</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L177-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, Line}" href="#ComplexRegions.closest-Tuple{Number, Line}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,L::Line)</code></pre><p>Find the point on line <code>L</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, Ray}" href="#ComplexRegions.closest-Tuple{Number, Ray}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,R::Ray)</code></pre><p>Find the point on ray <code>R</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number, Segment}" href="#ComplexRegions.closest-Tuple{Number, Segment}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closest(z,S::Segment)</code></pre><p>Find the point on segment <code>S</code> that lies closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.curve-Tuple{ComplexRegions.AbstractClosedPath, Integer}" href="#ComplexRegions.curve-Tuple{ComplexRegions.AbstractClosedPath, Integer}"><code>ComplexRegions.curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve(P::AbstractClosedPath,k::Integer)</code></pre><p>Return the <code>k</code>th curve in the path <code>P</code>. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L201-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.curve-Tuple{ComplexRegions.AbstractPath, Integer}" href="#ComplexRegions.curve-Tuple{ComplexRegions.AbstractPath, Integer}"><code>ComplexRegions.curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th curve in the path <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.curves-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.curves-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curves(P::AbstractPath)</code></pre><p>Return an array of the curves that make up the path <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.discretize" href="#ComplexRegions.discretize"><code>ComplexRegions.discretize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">discretize(P::SimplyConnectedRegion, n=600)</code></pre><p>Create an <code>n</code>×<code>n</code> grid of points on <code>P</code>. Points lying outside of <code>P</code> have a value of <code>NaN</code>.</p><p>If <code>P</code> is an exterior region, the points lie in a box a bit larger than the bounding box of <code>P</code>.</p><p>If keyword argument <code>limits</code> is specified, it must be a vector or tuple <code>(xmin, xmax, ymin, ymax)</code> specifying the limits of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/discretize.jl#L112-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.discretize-Tuple{ComplexRegions.AbstractClosedCurve, Integer}" href="#ComplexRegions.discretize-Tuple{ComplexRegions.AbstractClosedCurve, Integer}"><code>ComplexRegions.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretize(p, n)</code></pre><p>Discretize a path or curve at <code>n</code> points, roughly equidistributed by arc length. All vertices are also included.</p><p>Returns a tuple of vectors <code>t</code> and <code>z</code> such that <code>z[j]</code> is the point on the curve at parameter value <code>t[j]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/discretize.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.disk-Tuple{Circle}" href="#ComplexRegions.disk-Tuple{Circle}"><code>ComplexRegions.disk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disk(C::Circle)</code></pre><p>Construct the disk interior to <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.disk-Tuple{Number, Real}" href="#ComplexRegions.disk-Tuple{Number, Real}"><code>ComplexRegions.disk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disk(center::Number,radius::Real)</code></pre><p>Construct the disk with the given <code>center</code> and <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L94-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, Arc}" href="#ComplexRegions.dist-Tuple{Number, Arc}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,A::Arc)</code></pre><p>Compute the distance from number <code>z</code> to the arc <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/arcs.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, Circle}" href="#ComplexRegions.dist-Tuple{Number, Circle}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,C::Circle)</code></pre><p>Compute the distance from number <code>z</code> to the circle <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L120-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, ComplexRegions.AbstractPath}" href="#ComplexRegions.dist-Tuple{Number, ComplexRegions.AbstractPath}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,P::AbstractPath)</code></pre><p>Find the distance from the path <code>P</code> to the point <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L171-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, Line}" href="#ComplexRegions.dist-Tuple{Number, Line}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,L::Line)</code></pre><p>Compute the distance from number <code>z</code> to the line <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, Ray}" href="#ComplexRegions.dist-Tuple{Number, Ray}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,R::Ray)</code></pre><p>Compute the distance from number <code>z</code> to the ray <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L126-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number, Segment}" href="#ComplexRegions.dist-Tuple{Number, Segment}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(z,S::Segment)</code></pre><p>Compute the distance from number <code>z</code> to the segment <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.exterior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.exterior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.exterior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exterior(C)</code></pre><p>Construct the region exterior to  the closed curve or path <code>C</code>. If <code>C</code> is bounded, the bounded enclosure is chosen regardless of the orientation of <code>C</code>; otherwise, the region &quot;to the right&quot; is the exterior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.halfplane-Tuple{Line}" href="#ComplexRegions.halfplane-Tuple{Line}"><code>ComplexRegions.halfplane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">halfplane(L::Line)</code></pre><p>Construct the half-plane to the left of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L119-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.halfplane-Tuple{Number, Number}" href="#ComplexRegions.halfplane-Tuple{Number, Number}"><code>ComplexRegions.halfplane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">halfplane(a,b)</code></pre><p>Construct the half-plane to the left of the line from <code>a</code> to <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.interior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.interior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.interior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interior(C)</code></pre><p>Construct the region interior to the closed curve or path <code>C</code>. If <code>C</code> is bounded, the bounded enclosure is chosen regardless of the orientation of <code>C</code>; otherwise, the region &quot;to the left&quot; is the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isinside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.isinside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinside(X,z)</code></pre><p>Detect whether <code>z</code> lies inside the closed curve or path <code>X</code>. For a bounded path, this always means the bounded region enclosed by the curve, regardless of orientation; for an unbounded path, it means the region &quot;to the left&quot; as one walks along the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L94-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number, Line}" href="#ComplexRegions.isleft-Tuple{Number, Line}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isleft(z,L::Line)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of line <code>L</code>. This means that the angle it makes with <code>tangent(L)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the curve should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number, Ray}" href="#ComplexRegions.isleft-Tuple{Number, Ray}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isleft(z,R::Ray)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of ray <code>R</code>. This means that the angle it makes with <code>tangent(R)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) ray should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number, Segment}" href="#ComplexRegions.isleft-Tuple{Number, Segment}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isleft(z,S::Segment)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of segment <code>S</code>. This means that the angle it makes with <code>tangent(S)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) segment should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isoutside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.isoutside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.isoutside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isoutside(X,z)</code></pre><p>Detect whether <code>z</code> lies outside the closed curve or path <code>X</code>. For a bounded path, this always means the unbounded region complementary to the enclosure of the curve, regardless of orientation; for an unbounded path, it means the region &quot;to the right&quot; as one walks along the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ispositive-Tuple{CircularPolygon}" href="#ComplexRegions.ispositive-Tuple{CircularPolygon}"><code>ComplexRegions.ispositive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispositive(p::CircularPolygon)</code></pre><p>Determine whether the circular polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.ispositive-Tuple{Polygon}" href="#ComplexRegions.ispositive-Tuple{Polygon}"><code>ComplexRegions.ispositive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispositive(p::Polygon)</code></pre><p>Determine whether the polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L258-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number, Line}" href="#ComplexRegions.isright-Tuple{Number, Line}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isright(z,L::Line)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of line <code>L</code>. This means that the angle it makes with <code>tangent(L)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the curve should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number, Ray}" href="#ComplexRegions.isright-Tuple{Number, Ray}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isright(z,R::Ray)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of ray <code>R</code>. This means that the angle it makes with <code>tangent(R)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) ray should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/rays.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number, Segment}" href="#ComplexRegions.isright-Tuple{Number, Segment}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isright(z,S::Segment)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of segment <code>S</code>. This means that the angle it makes with <code>tangent(S)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) segment should give <code>false</code> in both cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.n_gon-Tuple{Integer}" href="#ComplexRegions.n_gon-Tuple{Integer}"><code>ComplexRegions.n_gon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_gon(n)</code></pre><p>Construct a regular n-gon with vertices on the unit circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L358-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.normal-Tuple{ComplexRegions.AbstractCurve, Real}" href="#ComplexRegions.normal-Tuple{ComplexRegions.AbstractCurve, Real}"><code>ComplexRegions.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal(C::AbstractCurve,t::Real)</code></pre><p>Find the unit complex number in the direction of the leftward-pointing normal to curve <code>C</code> at parameter value <code>t</code> in [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L51-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.normal-Tuple{ComplexRegions.AbstractPath, Real}" href="#ComplexRegions.normal-Tuple{ComplexRegions.AbstractPath, Real}"><code>ComplexRegions.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal(P::AbstractPath,t::Real)</code></pre><p>Compute a complex-valued normal to path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.point-Tuple{ComplexRegions.AbstractCurve, Real}" href="#ComplexRegions.point-Tuple{ComplexRegions.AbstractCurve, Real}"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point(C::AbstractCurve,t::Real)</code></pre><p>Find the point on curve <code>C</code> at parameter value <code>t</code>, which should lie in the interval [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractCurve, AbstractArray{T}}} where T&lt;:Real" href="#ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractCurve, AbstractArray{T}}} where T&lt;:Real"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point(C::AbstractCurve,t::AbstractArray)</code></pre><p>Vectorize the <code>point</code> function for curve <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath, AbstractArray{T}}} where T&lt;:Real" href="#ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath, AbstractArray{T}}} where T&lt;:Real"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point(P::AbstractPath,t::Real)
P(t)</code></pre><p>Compute the point along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1.</p><pre><code class="nohighlight hljs">point(P::AbstractPath,t::AbstractVector)</code></pre><p>Vectorize the <code>point</code> method for path <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.rectangle-Tuple{AbstractVector, AbstractVector}" href="#ComplexRegions.rectangle-Tuple{AbstractVector, AbstractVector}"><code>ComplexRegions.rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rectangle(xlim, ylim)</code></pre><p>Construct the rectangle defined by <code>xlim[1]</code> &lt; Re(z) &lt; <code>xlim[2]</code>, <code>ylim[1]</code> &lt; Im(z) &lt; <code>ylim[2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L336-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.rectangle-Tuple{AbstractVector{&lt;:Number}}" href="#ComplexRegions.rectangle-Tuple{AbstractVector{&lt;:Number}}"><code>ComplexRegions.rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rectangle(v)</code></pre><p>Construct the rectangle with vertices given in the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L316-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.rectangle-Tuple{Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat, Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat}" href="#ComplexRegions.rectangle-Tuple{Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat, Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat}"><code>ComplexRegions.rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rectangle(z1, z2)</code></pre><p>Construct the axes-aligned rectangle whose opposing corners are the given complex values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/polygons.jl#L351-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number, Circle}" href="#ComplexRegions.reflect-Tuple{Number, Circle}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reflect(z,C::Circle)</code></pre><p>Reflect the value <code>z</code> across the circle <code>C</code>. (For reflection of a circle through a point, use translation and negation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/circles.jl#L132-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number, Line}" href="#ComplexRegions.reflect-Tuple{Number, Line}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reflect(z,L::Line)</code></pre><p>Reflect the value <code>z</code> across the line <code>L</code>. (For reflection of a line through a point, use translation and negation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/lines.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number, Segment}" href="#ComplexRegions.reflect-Tuple{Number, Segment}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reflect(z,S::Segment)</code></pre><p>Reflect the value <code>z</code> across the extension of segment <code>S</code> to a line. (For reflection of a segment through a point, use translation and negation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/segments.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.tangent-Tuple{ComplexRegions.AbstractCurve, Real}" href="#ComplexRegions.tangent-Tuple{ComplexRegions.AbstractCurve, Real}"><code>ComplexRegions.tangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tangent(C::AbstractCurve,t::Real)</code></pre><p>Find the complex number representing the tangent to curve <code>C</code> at parameter value <code>t</code> in [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.tangent-Tuple{ComplexRegions.AbstractPath, Real}" href="#ComplexRegions.tangent-Tuple{ComplexRegions.AbstractPath, Real}"><code>ComplexRegions.tangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tangent(P::AbstractPath,t::Real)</code></pre><p>Compute the complex-valued tangent along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L87-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractCurve, Real}" href="#ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractCurve, Real}"><code>ComplexRegions.unittangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unittangent(C::AbstractCurve,t::Real)</code></pre><p>Find the complex number representing the unit tangent to curve <code>C</code> at parameter value <code>t</code> in [0,1]. For Lines, Segments, and Rays, the <code>t</code> argument is optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/curves.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractPath, Real}" href="#ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractPath, Real}"><code>ComplexRegions.unittangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unittangent(P::AbstractPath,t::Real)</code></pre><p>Compute the complex-valued unit tangent along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L96-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.vertex-Tuple{ComplexRegions.AbstractClosedPath, Integer}" href="#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractClosedPath, Integer}"><code>ComplexRegions.vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertex(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th vertex of the path <code>P</code>. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.vertex-Tuple{ComplexRegions.AbstractPath, Integer}" href="#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractPath, Integer}"><code>ComplexRegions.vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertex(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th vertex of the path <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.vertices-Tuple{ComplexRegions.AbstractClosedPath}" href="#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractClosedPath}"><code>ComplexRegions.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(P::AbstractClosedPath)</code></pre><p>Return an array of the unique vertices (endpoints of the curves) of the closed path <code>P</code>. The length is equal the number of curves in <code>P</code>, i.e., the first/last vertex is not duplicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L213-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.vertices-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(P::AbstractPath)</code></pre><p>Return an array of the vertices (endpoints of the curves) of the path <code>P</code>. The length is one greater than the number of curves in <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.winding-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.winding-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.winding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">winding(P,z)</code></pre><p>Compute the winding number of a closed curve or path <code>P</code> about the point <code>z</code>. Each counterclockwise rotation about <code>z</code> contributes +1, and each clockwise rotation about it counts -1. The winding number is zero for points not in the region enclosed by <code>P</code>. </p><p>The result is unreliable for points lying on <code>P</code>, for which the problem is ill-posed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L16-L21">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:+-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X + z
z + X</code></pre><p>Translate a curve, path, or region <code>X</code> by a complex number <code>z</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Number, Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:--Tuple{Number, Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z - X</code></pre><p>Negate a curve, path, or region <code>X</code> (reflect through the origin) and translate by <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}, Number}" href="#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}, Number}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X - z</code></pre><p>Translate a curve, path, or region <code>X</code> by a number <code>-z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-X</code></pre><p>Negate a curve, path, or region <code>X</code> (reflect through the origin).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/docs.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreal-Tuple{ComplexRegions.AbstractPath}" href="#Base.isreal-Tuple{ComplexRegions.AbstractPath}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreal(P::AbstractPath)</code></pre><p>Return <code>true</code> if the path is entirely on the real axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/paths.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.default-Tuple{}" href="#ComplexRegions.default-Tuple{}"><code>ComplexRegions.default</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ComplexRegions.default()</code></pre><p>Return a dictionary of global default settings for the ComplexRegions package.</p><pre><code class="nohighlight hljs">ComplexRegions.default(key=value)</code></pre><p>Change a global default setting in the running instance of the ComplexRegions package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/ComplexRegions.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexRegions.quad-Tuple{Rectangle}" href="#ComplexRegions.quad-Tuple{Rectangle}"><code>ComplexRegions.quad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quad(R::Rectangle)</code></pre><p>Construct the rectangle interior to <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/complexvariables/ComplexRegions.jl/blob/b12ffdf9d0c286beb07b1f27f83c28f3cbbfa650/src/simplyconnected.jl#L107-L110">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mobius/">« Möbius</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 10 July 2024 19:33">Wednesday 10 July 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
