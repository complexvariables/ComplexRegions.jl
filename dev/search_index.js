var documenterSearchIndex = {"docs":
[{"location":"curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"A curve is meant to be a smooth, non-self-intersecting curve in the extended complex plane. There is a generic Curve type that requires you to specify an explicit parameterization; it is not checked for smoothness or even continuity.","category":"page"},{"location":"curves/#interface_curves","page":"Curves","title":"Abstract interface","text":"","category":"section"},{"location":"curves/#AbstractCurve","page":"Curves","title":"AbstractCurve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Every AbstractCurve type is expected to implement the following methods. (Here C represents a value of type AbstractCurve and z is a number.)","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Method Description\npoint(C, t::Real) Complex point on C at parameter value t in [0,1].\ntangent(C, t::Real) Complex tangent to C at t.\nreverse(C) Reverse the direction of traversal.\nisfinite(C) True if the curve does not pass through infinity.\nconj(C) Complex conjugate of the curve.\nC+z Translate of the curve by z.\n-C Negate the curve.\nC*z Multiply the curve C by complex number z; i.e., scale and rotate it about the origin.\ninv(C) Invert the curve pointwise.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"There are also default implementations of the following methods:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Method Description\npoint(C, t::AbstractArray{T<:Real}) Vectorization of the point method.\nz+C, C-z, z-C, z*C, C/z, z/C Translate/rotate/scale by a complex value.\nunittangent(C, t::Real) Normalized tangent to C at t.\nnormal(C, t::Real) Unit (leftward) normal to C at t.\narclength(C) Arc length of C.","category":"page"},{"location":"curves/#AbstractClosedCurve","page":"Curves","title":"AbstractClosedCurve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"The AbstractClosedCurve subtype is used to signify that the starting and ending points of the curve are (approximately) identical. In addition to the methods of AbstractCurve, it provides the following:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Method Description\nwinding(C, z::Number) Winding number of C about z.\nisinside(z::Number, C) Detect whether z lies inside the curve.\nisoutside(z::Number, C) Detect whether z lies outside the curve.","category":"page"},{"location":"curves/#generic_curves","page":"Curves","title":"Generic types","text":"","category":"section"},{"location":"curves/#Curve","page":"Curves","title":"Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"A Curve represents an implementation of AbstractCurve that requires only an explicit parameterization of the curve. Given the (bounded) complex-valued function f defined on 01, then C=Curve(f) represents the curve z=f(t). If f is defined on ab instead, then C=Curve(f,a,b) is appropriate, but all future work with C uses the standard interval 01 for the parameter. All Curve values are expected to be finite; i.e., isfinite(C) will always be true.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"By default, a tangent to C is computed when needed using a simple finite difference, resulting in less precision than the representation of the points on C (particularly near the endpoints). If an accurate function df is available for the complex-valued tangent z(t), it can be used via Curve(f,df) or Curve(f,df,a,b).","category":"page"},{"location":"curves/#ClosedCurve","page":"Curves","title":"ClosedCurve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"A ClosedCurve implements AbstractClosedCurve and is similar to a Curve, but the parameterization is checked against f(0)approx f(1) (or f(b)approx f(a)), up to a tolerance.","category":"page"},{"location":"curves/#subtypes_curves","page":"Curves","title":"Specific subtypes","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"The following important particular types of curves are provided, together with appropriate particular methods. All of them provide the syntax C(t) as equivalent to point(C,t).","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Each type below is parameterized; e.g., Line{T}, where T is either a native Complex type, or a Polar or Spherical type from ComplexValues. Points on the curve have the type T, which mainly affects how they are plotted. You can convert the value type, so for example, Spherical(C) will be plotted on the Riemann sphere.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"In addition to the minimal methods set by the AbstractCurve definition above, each of these types provides the following methods. (C is a value of one of these types, and z is a number.)","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Method Description\narg(C, z) Parameter value of a given point on the curve.\nisapprox(C1, C2) Determine whether two values represent the same curve.\nisleft(z, C), isright(z, C) Determine whether a point lies \"to the left\" or \"to the right\" of a line, ray, or segment cin its given orientation.\ndist(z, C) Distance from a point to the curve.\nclosest(z, C) Point on the curve nearest to a given number.","category":"page"},{"location":"curves/#Line","page":"Curves","title":"Line","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Use L=Line(a, b) to create a line through the values a and b. Given a point p on the line and a complex s whose complex sign gives the direction of the line, another syntax is Line(p, direction=s). Finally, with a point p on the line and the angle θ of the line, use Line(p, angle=θ).","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Like other curves, a line is parameterized over 01, with L(0) and L(1) both being infinity. Use reflect(z, L) to find the reflection of a point z across line L.","category":"page"},{"location":"curves/#Ray","page":"Curves","title":"Ray","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Use Ray(z, θ) to construct a ray starting at z and extending to infinity at the angle θ. Use Ray(z, θ, true) to reverse the ray, so it extends from infinity to z.","category":"page"},{"location":"curves/#Segment","page":"Curves","title":"Segment","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Segment(a, b) constructs the line segment from a to b.","category":"page"},{"location":"curves/#Circle","page":"Curves","title":"Circle","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Circle(z, r) constructs a circle centered at z with radius r, oriented counterclockwise (positively). UseCircle(z,r,false) to make the circle with clockwise orientation.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Circle(a, b, c) constructs the circle through the points a, b, and c. The ordering of the points determines the orientation of the circle. If the points are collinear, a Line is returned instead.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Use reflect(z, C) to reflect a point z through the circle C.","category":"page"},{"location":"curves/#Arc","page":"Curves","title":"Arc","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Arc(a, b, c) constructs the circular arc through the given three points. If the points are collinear, a Segment is returned.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Given a Circle C, the syntax Arc(C, start, delta) constructs an arc from C starting at the given start value and extending an amount delta. These latter values are expressed as fractions of a full rotation starting from the real axis. If delta is negative, it effectively reverses the orientation of C.","category":"page"},{"location":"curves/#Examples","page":"Curves","title":"Examples","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Some examples:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using ComplexRegions","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"ℓ = Line(1/2, 1/2+1im)  # line through 0.5 and 0.5+1i\nc = 1 / ℓ              # a circle\nwinding(c, 1.5), winding(c, -1)\ntangent(c, 0.75)\nreflect(-1, c)          # reflection of a point through the circle\n2c - 2","category":"page"},{"location":"mobius/#Möbius","page":"Möbius","title":"Möbius","text":"","category":"section"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"using ComplexRegions","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"A Möbius transformation (also called bilinear or fractional-linear transformation) is the ratio of two linear polynomials:","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"f(z)=fracaz+bcz+d","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Among other notable properties, they map circles and lines to other circles and lines.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"For convenience of typing on some keyboards, Mobius is an alias for Möbius in the package.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"The package defines a Möbius type that can be constructed in a variety of ways:","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Möbius(a, b, c, d)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Specify the coefficients as in the formula above.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Möbius(A)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Specify the coefficients as the matrix A=abcd.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Möbius(z, w)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Construct the unique transformation that maps the three points z[1], z[2], z[3] to w[1], w[2], w[3], respectively. Either vector of points may include Inf.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Möbius(C1, C2)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Construct a transformation that maps the Line or Circle C1 to the Line or Circle C2.","category":"page"},{"location":"mobius/#Methods","page":"Möbius","title":"Methods","text":"","category":"section"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Suppose f is a value of type Möbius. Then f(z) evaluates the transformation at the number z. In addition, f(C), where C is a Circle or Line, returns the Circle or Line that is the image of C under f. Similarly, f(R), where R is an AbstractDisk or AbstractHalfplane, returns the appropriate type of image region. For example,","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"f = Möbius(Line(-1, 1), Circle(0, 1))\nf(upperhalfplane)\nisapprox(ans, unitdisk)","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Two other methods are defined:","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"inv(f)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Construct the inverse transformation.","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"f∘g (type \"\\circ\" followed by tab key)\n","category":"page"},{"location":"mobius/","page":"Möbius","title":"Möbius","text":"Construct the composed map, z mapsto f(g(z)).","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Exported-types","page":"API Reference","title":"Exported types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ComplexRegions]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api/#ComplexRegions.Annulus","page":"API Reference","title":"ComplexRegions.Annulus","text":"(type) Annulus\n\nRepresentation of the region between two circles.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Annulus-Union{Tuple{S}, Tuple{T}, Tuple{Circle{T}, Circle{S}}} where {T, S}","page":"API Reference","title":"ComplexRegions.Annulus","text":"Annulus(radouter,radinner)\nAnnulus(radouter,radinner,center)\n\nConstruct a concentric annulus of outer radius radouter and inner radius radinner centered at center. If the center is not given, the origin is used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Arc","page":"API Reference","title":"ComplexRegions.Arc","text":"(type) Arc{T<:AnyComplex} in the complex plane\n\nEach Arc type is parameterized according to the common type of its complex input arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Arc-Union{Tuple{T}, Tuple{Circle{T}, Real, Real}} where T","page":"API Reference","title":"ComplexRegions.Arc","text":"Arc(C, start, delta)\n\nConsruct an arc that is the part of the Circle C starting at parameter value start and ending at start+delta. The values are expressed in terms of fractions of a complete circle. The start value should be in [0,1), and delta should be in [-1,1].\n\nArc(a, b, c)\n\nConstruct the arc starting at point a, passing through b, and ending at c. If the three points are collinear, a Segment is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Circle","page":"API Reference","title":"ComplexRegions.Circle","text":"Circle(zc, r, ccw=true)\n\nConstruct the circle with given center zc, radius r, and orientation (defaults to counterclockwise).\n\nCircle(a, b, c)\n\nConstruct the circle passing through the given three numbers. Orientation is determined so that the values are visited in the given order. If the three points are collinear (including when one of the given values is infinite), a Line is returned instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Circle-2","page":"API Reference","title":"ComplexRegions.Circle","text":"(type) Circle{T<:AnyComplex} in the complex plane\n\nEach Circle type is parameterized according to the common type of its complex input arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.CircularPolygon","page":"API Reference","title":"ComplexRegions.CircularPolygon","text":"(type) CircularPolygon\n\nType for closed paths consisting entirely of arcs, segments, and rays.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.CircularPolygon-Union{Tuple{ComplexRegions.AbstractPath{T}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.CircularPolygon","text":"CircularPolygon(p::AbstractPath; tol=<default>)\nCircularPolygon(p::AbstractVector; tol=<default>)\n\nConstruct a circular polygon from a (possibly closed) path, or from a vector of curves. The tol parameter is a tolerance used when checking continuity and closedness of the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.ClosedCurve","page":"API Reference","title":"ComplexRegions.ClosedCurve","text":"ClosedCurve(f; tol=<default>)\nClosedCurve(f,a,b; tol=<default)\n\nConstruct a ClosedCurve object from the complex-valued function point accepting an argument in the interval [0,1]. The constructor checks whether f(0)≈f(1) to tolerance tol. If a and b are given, they are the limits of the parameter in the call to the supplied f. However, the resulting object will be defined on [0,1], which is internally scaled to [a,b].\n\nClosedCurve(f,df[,a,b]; tol=<default>)\n\nConstruct a closed curve with point location and tangent given by the complex-valued functions f and df, respectively, optionally with given limits on the parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.ClosedCurve-2","page":"API Reference","title":"ComplexRegions.ClosedCurve","text":"(type) Smooth closed curve defined by an explicit function of a real paramerter in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.ClosedPath","page":"API Reference","title":"ComplexRegions.ClosedPath","text":"(type) ClosedPath\n\nGeneric implementation of an AbstractClosedPath.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.ClosedPath-Union{Tuple{AbstractVector{<:ComplexRegions.AbstractCurve{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.ClosedPath","text":"ClosedPath(c::AbstractVector; tol=<default>)\nClosedPath(P::Path; tol=<default>)\n\nGiven a vector c of curves, or an existing path, construct a closed path. The path is checked for continuity (to tolerance tol) at all of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.ConnectedRegion","page":"API Reference","title":"ComplexRegions.ConnectedRegion","text":"(type) ConnectedRegion{N}\n\nRepresentation of a N-connected region in the extended complex plane.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.ConnectedRegion-Union{Tuple{T}, Tuple{Union{Nothing, ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}, AbstractVector{<:Union{ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}}}} where T","page":"API Reference","title":"ComplexRegions.ConnectedRegion","text":"ConnectedRegion(outer, inner)\n\nConstruct an open connected region by specifying its boundary components. The outer boundary could be nothing or a closed curve or path. The inner boundary should be a vector of one or more nonintersecting closed curves or paths. The defined region is interior to the outer boundary and exterior to all the components of the inner boundary, regardless of the orientations of the given curves.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Curve","page":"API Reference","title":"ComplexRegions.Curve","text":"(type) Smooth curve defined by an explicit function of a real paramerter in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Line","page":"API Reference","title":"ComplexRegions.Line","text":"(type) Line{T<:AnyComplex} in the complex plane\n\nEach Line type is parameterized according to the common type of its complex input arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Line-Tuple{Number, Number}","page":"API Reference","title":"ComplexRegions.Line","text":"Line(a, b)\n\nConstruct the line passing through the two given points.\n\nLine(a, direction=z)\n\nConstruct the line through the given point and parallel to the complex sign of the given direction value. \n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius","page":"API Reference","title":"ComplexRegions.Möbius","text":"(type) Möbius\n\nRepresentation of a Möbius or bilinear transformation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Möbius-NTuple{4, Number}","page":"API Reference","title":"ComplexRegions.Möbius","text":"Möbius(a, b, c, d)\n\nConstruct the Möbius map z  (az+b)  (cz+d) from its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Tuple{AbstractMatrix}","page":"API Reference","title":"ComplexRegions.Möbius","text":"Möbius(A::AbstractMatrix)\n\nConstruct the Möbius map z  (az+b)  (cz+d) from the matrix [a b;c d].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Tuple{AbstractVector, AbstractVector}","page":"API Reference","title":"ComplexRegions.Möbius","text":"Möbius(z::AbstractVector, w::AbstractVector)\n\nConstruct the Möbius map that transforms the points z[k] to w[k] for k=1,2,3. Values of Inf are permitted in both vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Tuple{Number}","page":"API Reference","title":"ComplexRegions.Möbius","text":"f(z::Number)\n\nEvaluate the Möbius map f at a real or complex value z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Union{Tuple{T}, Tuple{Union{Circle{T}, Line{T}}, Union{Circle{T}, Line{T}}}} where T","page":"API Reference","title":"ComplexRegions.Möbius","text":"Möbius(C1, C2)\n\nConstruct a Möbius map that transforms the curve C1 to C2. Both curves must be either a Line or Circle. (These maps are not uniquely determined.)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Union{Tuple{Union{Arc{T}, Segment{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.Möbius","text":"f(C::Union{Arc,Segment})\n\nFind the image of the arc or segment C under the Möbius map f. The result is also either an Arc or a Segment.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Union{Tuple{Union{Circle{T}, Line{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.Möbius","text":"f(C::Union{Circle,Line})\n\nFind the image of the circle or line C under the Möbius map f. The result is also either a Circle or a Line.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Möbius-Union{Tuple{Union{ComplexRegions.ExteriorSimplyConnectedRegion{T, Circle{T}}, ComplexRegions.InteriorSimplyConnectedRegion{T, Circle{T}} where T, Union{ComplexRegions.ExteriorSimplyConnectedRegion{T, Line{T}}, ComplexRegions.InteriorSimplyConnectedRegion{T, Line{T}}} where T}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.Möbius","text":"f(R::Union{AbstractDisk,AbstractHalfplane})\n\nIf R is an AbstractDisk or an AbstractHalfplane, find its image under the Möbius map f. The result is also either an AbstractDisk or an AbstractHalfplane.\n\nExamples\n\njulia> f = Möbius(Line(-1,1),Circle(0,1))\nMöbius transformation:\n\n   (1.0 + 0.9999999999999999im) z + (3.666666666666666 - 1.666666666666667im)\n   ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n   (1.0 + 0.9999999999999999im) z + (-1.666666666666666 + 3.6666666666666665im)\n\njulia> f(upperhalfplane)\nDisk interior to:\n   Circle(-5.55112e-17+2.22045e-16im,1.0)\n\njulia> isapprox(ans,unitdisk)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Path","page":"API Reference","title":"ComplexRegions.Path","text":"(type) Path\n\nGeneric implementation of an AbstractPath.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Path-Union{Tuple{AbstractVector{<:ComplexRegions.AbstractCurve{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.Path","text":"Path(c::AbstractVector; tol=<default>)\n\nGiven a vector c of curves, construct a path. The path is checked for continuity (to tolerance tol) at the interior vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Polygon","page":"API Reference","title":"ComplexRegions.Polygon","text":"(type) Polygon\n\nType for closed paths consisting entirely of segments and rays.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Polygon-Union{Tuple{Union{ComplexRegions.AbstractPath{T}, AbstractVector{<:ComplexRegions.AbstractCurve{T}}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.Polygon","text":"Polygon(p::AbstractPath; tol=<default>)\nPolygon(p::AbstractVector{<:AbstractCurve}; tol=<default>)\n\nConstruct a polygon from a (possibly closed) path, or from a vector of curves. The tol parameter is a tolerance used when checking continuity and closedness of the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.Ray","page":"API Reference","title":"ComplexRegions.Ray","text":"Ray(a, θ, reverse=false)\n\nConstruct the ray starting at a and extending to infinity at the angle θ. If reverse is true, the ray is considered to extend from infinity to a at angle -θ.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Ray-2","page":"API Reference","title":"ComplexRegions.Ray","text":"(type) Ray{T<:AnyComplex} in the complex plane\n\nEach Ray type is parameterized according to the common type of its complex input arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.RegionIntersection","page":"API Reference","title":"ComplexRegions.RegionIntersection","text":"(type) RegionIntersection\n\nRepresentation of the intersection of two regions.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.RegionUnion","page":"API Reference","title":"ComplexRegions.RegionUnion","text":"(type) RegionUnion\n\nRepresentation of the union of two regions.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Segment","page":"API Reference","title":"ComplexRegions.Segment","text":"(type) Segment{T<:AbstractFloat} in the complex plane\n\nEach Segment type is parameterized according to the common type of its complex input arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComplexRegions.Segment-Tuple{Number, Number}","page":"API Reference","title":"ComplexRegions.Segment","text":"Segment(a, b)\n\nConsruct a segment that starts at value a and ends at b.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexValues.Polar-Tuple{ComplexRegions.AbstractCurve}","page":"API Reference","title":"ComplexValues.Polar","text":"Polar(::AbstractCurve)\n\nInterpret a curve as having points of type Polar.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexValues.Spherical-Tuple{ComplexRegions.AbstractCurve}","page":"API Reference","title":"ComplexValues.Spherical","text":"Spherical(::AbstractCurve)\n\nInterpret a curve as having points of type Spherical.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-functions","page":"API Reference","title":"Exported functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ComplexRegions]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Base.:!-Union{Tuple{ComplexRegions.InteriorSimplyConnectedRegion{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"API Reference","title":"Base.:!","text":"!(R::SimplyConnectedRegion)\n\nCompute the region complementary to R. This is not quite set complementation, as neither region includes its boundary. The complement is always simply connected in the extended plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:∘-Tuple{Möbius, Möbius}","page":"API Reference","title":"Base.:∘","text":"∘(f::Möbius,g::Möbius)\n\nCompose two Möbius transformations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.conj-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}","page":"API Reference","title":"Base.conj","text":"conj(X)\n\nConstruct the complex conjugate of curve, path, or region X. (Reverses the orientation of a curve or path.)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Tuple{Number, ComplexRegions.AbstractRegion}","page":"API Reference","title":"Base.in","text":"in(z::Number,R::AbstractRegion;tol=<default>)\nz ∈ R   (type \"\\in\" followed by tab)\n\nTrue if z is in the region R.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.intersect","page":"API Reference","title":"Base.intersect","text":"intersect(c1::AbstractCurve,c2::AbstractCurve; tol=<default>)\n\nFind the intersection(s) of two curves. The result could be a vector of zero or more values, or a curve.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.intersect-Union{Tuple{T}, Tuple{S}, Tuple{ComplexRegions.AbstractRegion{T}, ComplexRegions.AbstractRegion{S}}} where {S, T}","page":"API Reference","title":"Base.intersect","text":"intersect(R1::AbstractRegion,R2::AbstractRegion)\nR1 ∩ R2    (type \"\\cap\" followed by tab key)\n\nCreate the region that is the intersection of R1 and R2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Möbius}","page":"API Reference","title":"Base.inv","text":"inv(f::Möbius)\n\nFind the inverse of a Möbius transformation. This is the functional inverse, not 1/f(z).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Segment}","page":"API Reference","title":"Base.inv","text":"inv(S)\n\nInvert the segment S through the origin. In general the inverse is an Arc, though the result is a Segment if S would pass through the origin when extended.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}","page":"API Reference","title":"Base.inv","text":"inv(X)\n\nInvert a curve, path, or region pointwise.\t\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Union{Tuple{Arc{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.inv","text":"inv(A)\n\nInvert the arc A through the origin. In general the inverse is an Arc, though the result is a Segment if the arc's circle passes through the origin.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Union{Tuple{Circle{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.inv","text":"inv(C)\n\nInvert the circle C through the origin. In general the inverse is a Circle, though the result is a Line if C passes through the origin.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Union{Tuple{Line{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.inv","text":"inv(L)\n\nInvert a line L through the origin. In general the inverse is a Circle through the inverse of any three points on the line.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Union{Tuple{Ray{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.inv","text":"inv(R)\n\nInvert the ray R through the origin. In general the inverse is an Arc.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Tuple{ComplexRegions.AbstractPath, ComplexRegions.AbstractPath}","page":"API Reference","title":"Base.isapprox","text":"isapprox(P1::AbstractPath,R2::AbstractPath; tol=<default>)\nP1 ≈ P2       (type \"\\approx\" followed by tab key)\n\nDetermine whether P1 and P2 represent the same path, up to tolerance tol, irrespective of the parameterization of its curves.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{R}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{SimplyConnectedRegion{T, U}, SimplyConnectedRegion{S, R}}} where {S, T, U, R}","page":"API Reference","title":"Base.isapprox","text":"isapprox(R1::SimplyConnectedRegion, R2::SimplyConnectedRegion; tol=<default>)\n\nDetermine whether R1 and R2 represent the same region, up to tolerance tol. Equivalently, determine whether their boundaries are the same.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{S}, Tuple{T}, Tuple{Line{T}, Line{S}}} where {T, S}","page":"API Reference","title":"Base.isapprox","text":"isapprox(L1::Line, L2::Line; tol=<default>)\nL1 ≈ L2\n\nDetermine if L1 and L2 represent the same line, irrespective of the type or values of its parameters. Identity is determined by agreement within tol, which is interpreted as the weaker of absolute and relative differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{Arc{S}, Arc{T}}} where {S, T}","page":"API Reference","title":"Base.isapprox","text":"isapprox(A1::Arc,A2::Arc; tol=<default>)\nA1 ≈ A2\n\nDetermine if A1 and A2 represent the same arc, irrespective of the type or values of its parameters. Identity is determined by agreement within tol, which is interpreted as the weaker of absolute and relative differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{Circle{S}, Circle{T}}} where {S, T}","page":"API Reference","title":"Base.isapprox","text":"isapprox(C1::Circle,C2::Circle; tol=<default>)\nC1 ≈ C2\n\nDetermine if C1 and C2 represent the same circle, irrespective of the type or values of its parameters. Identity is determined by agreement within tol, which is interpreted as the weaker of absolute and relative differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{Ray{S}, Ray{T}}} where {S, T}","page":"API Reference","title":"Base.isapprox","text":"isapprox(R1::Ray, R2::Ray; tol=<default>)\nR1 ≈ R2\n\nDetermine if R1 and R2 represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within tol, which is interpreted as the weaker of absolute and relative differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{Segment{S}, Segment{T}}} where {S, T}","page":"API Reference","title":"Base.isapprox","text":"isapprox(S1::Segment,S2::Segment; tol=<default>)\nS1 ≈ S2\n\nDetermine if S1 and S2 represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within tol, which is interpreted as the weaker of absolute and relative differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isfinite-Tuple{ComplexRegions.AbstractCurve}","page":"API Reference","title":"Base.isfinite","text":"isfinite(C::AbstractCurve)\n\nReturn true if the curve is bounded in the complex plane (i.e., does not pass through infinity).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isfinite-Tuple{ComplexRegions.AbstractPath}","page":"API Reference","title":"Base.isfinite","text":"isfinite(P::AbstractPath)\n\nReturn true if the path is bounded in the complex plane (i.e., does not pass through infinity).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isfinite-Tuple{ComplexRegions.AbstractRegion}","page":"API Reference","title":"Base.isfinite","text":"isfinite(R::AbstractRegion)\n\nReturn true if the region is bounded in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reverse-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}","page":"API Reference","title":"Base.reverse","text":"reverse(X)\n\nConstruct a curve or path identical to X except with opposite direction of parameterization.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{Union{CircularPolygon, Polygon}, Circle}","page":"API Reference","title":"Base.truncate","text":"truncate(P::Union{CircularPolygon,Polygon},C::Circle)\n\nCompute a trucated form of the polygon by replacing each pair of rays incident at infinity with two segments connected by an arc along the given circle. This is not a true clipping of the polygon, as finite sides are not altered. The result is either a CircularPolygon or the original P.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{Union{CircularPolygon, Polygon}}","page":"API Reference","title":"Base.truncate","text":"truncate(P::Union{CircularPolygon,Polygon})\n\nApply truncate to P using a circle that is centered at the centroid of its finite vertices, and a radius twice the maximum from the centroid to the finite vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union-Union{Tuple{T}, Tuple{S}, Tuple{ComplexRegions.AbstractRegion{T}, ComplexRegions.AbstractRegion{S}}} where {S, T}","page":"API Reference","title":"Base.union","text":"union(R1::AbstractRegion,R2::AbstractRegion)\nR1 ∪ R2    (type \"\\cup\" followed by tab key)\n\nCreate the region that is the union of R1 and R2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.angles-Union{Tuple{ComplexRegions.AbstractClosedPath{T}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.angles","text":"angles(P::AbstractPath)\n\nReturn a vecrtor of the interior angles at the vertices of the path P. The length is one greater than the number of curves in P, and the first and last values are NaN.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.angles-Union{Tuple{ComplexRegions.AbstractPath{T}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.angles","text":"angles(P::AbstractPath)\n\nReturn a vecrtor of the interior angles at the vertices of the path P. The length is one greater than the number of curves in P, and the first and last values are NaN.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.angles-Union{Tuple{Polygon{T}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.angles","text":"angles(P::Polygon)\n\nCompute a vector of interior angles at the vertices of the polygon P. At a finite vertex these lie in (0,2π]; at an infinite vertex, the angle is in [-2π,0].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arclength-Tuple{Path}","page":"API Reference","title":"ComplexRegions.arclength","text":"arclength(P::Path)\n\nCompute the arclength of the path P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arclength-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}","page":"API Reference","title":"ComplexRegions.arclength","text":"arclength(X)\n\nFetch or compute the arc length of the curve or path X.\n\nExample\n\njulia> ellipse = ClosedCurve( t->cos(t)+2im*sin(t), 0,2π );\njulia> arclength(ellipse)  # good to about 10 digits\n9.688448219981513\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arg-Tuple{Line, Number}","page":"API Reference","title":"ComplexRegions.arg","text":"arg(L::Line, z)\n\nFind a parameter argument t such that L(t)==z is true. For an infinite z, return zero (but note that L(1) is also infinity).\n\nThis gives undefined results if z is not actually on the line.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arg-Tuple{Ray, Number}","page":"API Reference","title":"ComplexRegions.arg","text":"arg(R::Ray,z)\n\nFind the parameter argument t such that R(t)==z is true.\n\nThis gives undefined results if z is not actually on the ray.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arg-Tuple{Segment, Number}","page":"API Reference","title":"ComplexRegions.arg","text":"arg(S::Segment,z)\n\nFind the parameter argument t such that S(t)==z is true.\n\nThis gives undefined results if z is not actually on the segment.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arg-Union{Tuple{T}, Tuple{Arc{T}, Number}} where T","page":"API Reference","title":"ComplexRegions.arg","text":"arg(A::Arc,z)\n\nFind the parameter argument t such that A(t)==z is true.\n\nThis gives undefined results if z is not actually on the arc.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.arg-Union{Tuple{T}, Tuple{Circle{T}, Number}} where T","page":"API Reference","title":"ComplexRegions.arg","text":"arg(C::Circle,z)\n\nFind the parameter argument t such that C(t)==z is true.\n\nThis gives undefined results if z is not actually on the circle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.between-Union{Tuple{T}, Tuple{Union{ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}, Union{ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}}} where T","page":"API Reference","title":"ComplexRegions.between","text":"between(outer,inner)\n\nConstruct the region interior to the closed curve or path outer and interior to inner.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Tuple{Number, Arc}","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z,A::Arc)\n\nFind the point on arc A that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Tuple{Number, Circle}","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z,C::Circle)\n\nFind the point on circle C that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Tuple{Number, ComplexRegions.AbstractPath}","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z,P::AbstractPath)\n\nFind the point on the path P that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Tuple{Number, Line}","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z, L::Line)\n\nFind the point on line L that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Tuple{Number, Segment}","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z,S::Segment)\n\nFind the point on segment S that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.closest-Union{Tuple{T}, Tuple{Number, Ray{T}}} where T","page":"API Reference","title":"ComplexRegions.closest","text":"closest(z, R::Ray)\n\nFind the point on ray R that lies closest to z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.curve-Tuple{ComplexRegions.AbstractClosedPath, Integer}","page":"API Reference","title":"ComplexRegions.curve","text":"curve(P::AbstractClosedPath,k::Integer)\n\nReturn the kth curve in the path P. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first curve.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.curve-Tuple{ComplexRegions.AbstractPath, Integer}","page":"API Reference","title":"ComplexRegions.curve","text":"curve(P::AbstractPath,k::Integer)\n\nReturn the kth curve in the path P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.curves-Tuple{ComplexRegions.AbstractPath}","page":"API Reference","title":"ComplexRegions.curves","text":"curves(P::AbstractPath)\n\nReturn an array of the curves that make up the path P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.discretize-Union{Tuple{ComplexRegions.InteriorSimplyConnectedRegion{T, S}}, Tuple{S}, Tuple{T}, Tuple{ComplexRegions.InteriorSimplyConnectedRegion{T, S}, Any}} where {T, S}","page":"API Reference","title":"ComplexRegions.discretize","text":"discretize(P::SimplyConnectedRegion, n=600)\n\nCreate an n×n grid of points on P. Points lying outside of P have a value of NaN.\n\nIf P is an exterior region, the points lie in a box a bit larger than the bounding box of P.\n\nIf keyword argument limits is specified, it must be a vector or tuple (xmin, xmax, ymin, ymax) specifying the limits of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.discretize-Union{Tuple{T}, Tuple{ComplexRegions.AbstractClosedCurve{T}, Integer}} where T","page":"API Reference","title":"ComplexRegions.discretize","text":"discretize(p, n)\n\nDiscretize a path or curve at n points, roughly equidistributed by arc length. All vertices are also included.\n\nReturns a tuple of vectors t and z such that z[j] is the point on the curve at parameter value t[j].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.disk-Tuple{Circle}","page":"API Reference","title":"ComplexRegions.disk","text":"disk(C::Circle)\n\nConstruct the disk interior to C.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.disk-Tuple{Number, Real}","page":"API Reference","title":"ComplexRegions.disk","text":"disk(center::Number,radius::Real)\n\nConstruct the disk with the given center and radius.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, Arc}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z,A::Arc)\n\nCompute the distance from number z to the arc A.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, Circle}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z,C::Circle)\n\nCompute the distance from number z to the circle C.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, ComplexRegions.AbstractPath}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z,P::AbstractPath)\n\nFind the distance from the path P to the point z.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, Line}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z, L::Line)\n\nCompute the distance from number z to the line L.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, Ray}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z, R::Ray)\n\nCompute the distance from number z to the ray R.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.dist-Tuple{Number, Segment}","page":"API Reference","title":"ComplexRegions.dist","text":"dist(z,S::Segment)\n\nCompute the distance from number z to the segment S.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.exterior-Union{Tuple{Union{ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.exterior","text":"exterior(C)\n\nConstruct the region exterior to  the closed curve or path C. If C is bounded, the bounded enclosure is chosen regardless of the orientation of C; otherwise, the region \"to the right\" is the exterior.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.halfplane-Tuple{Line}","page":"API Reference","title":"ComplexRegions.halfplane","text":"halfplane(L::Line)\n\nConstruct the half-plane to the left of L.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.halfplane-Tuple{Number, Number}","page":"API Reference","title":"ComplexRegions.halfplane","text":"halfplane(a,b)\n\nConstruct the half-plane to the left of the line from a to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.interior-Union{Tuple{Union{ComplexRegions.AbstractClosedCurve{T}, ComplexRegions.AbstractClosedPath{T}}}, Tuple{T}} where T","page":"API Reference","title":"ComplexRegions.interior","text":"interior(C)\n\nConstruct the region interior to the closed curve or path C. If C is bounded, the bounded enclosure is chosen regardless of the orientation of C; otherwise, the region \"to the left\" is the interior.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isinside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}","page":"API Reference","title":"ComplexRegions.isinside","text":"isinside(X,z)\n\nDetect whether z lies inside the closed curve or path X. For a bounded path, this always means the bounded region enclosed by the curve, regardless of orientation; for an unbounded path, it means the region \"to the left\" as one walks along the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isleft-Tuple{Number, Line}","page":"API Reference","title":"ComplexRegions.isleft","text":"isleft(z, L::Line)\n\nDetermine whether the number z lies \"to the left\" of line L. This means that the angle it makes with tangent(L) is in the interval (0,π).\n\nNote that isleft and isright are not logical opposites; a point on the curve should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isleft-Tuple{Number, Segment}","page":"API Reference","title":"ComplexRegions.isleft","text":"isleft(z,S::Segment)\n\nDetermine whether the number z lies \"to the left\" of segment S. This means that the angle it makes with tangent(S) is in the interval (0,π).\n\nNote that isleft and isright are not logical opposites; a point on the (extended) segment should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isleft-Union{Tuple{T}, Tuple{Number, Ray{T}}} where T","page":"API Reference","title":"ComplexRegions.isleft","text":"isleft(z, R::Ray)\n\nDetermine whether the number z lies \"to the left\" of ray R. This means that the angle it makes with tangent(R) is in the interval (0,π).\n\nNote that isleft and isright are not logical opposites; a point on the (extended) ray should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isoutside-Tuple{Number, Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}","page":"API Reference","title":"ComplexRegions.isoutside","text":"isoutside(X,z)\n\nDetect whether z lies outside the closed curve or path X. For a bounded path, this always means the unbounded region complementary to the enclosure of the curve, regardless of orientation; for an unbounded path, it means the region \"to the right\" as one walks along the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.ispositive-Tuple{CircularPolygon}","page":"API Reference","title":"ComplexRegions.ispositive","text":"ispositive(p::CircularPolygon)\n\nDetermine whether the circular polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.ispositive-Tuple{Polygon}","page":"API Reference","title":"ComplexRegions.ispositive","text":"ispositive(p::Polygon)\n\nDetermine whether the polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isright-Tuple{Number, Line}","page":"API Reference","title":"ComplexRegions.isright","text":"isright(z, L::Line)\n\nDetermine whether the number z lies \"to the right\" of line L. This means that the angle it makes with tangent(L) is in the interval (-π,0).\n\nNote that isleft and isright are not logical opposites; a point on the curve should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isright-Tuple{Number, Ray}","page":"API Reference","title":"ComplexRegions.isright","text":"isright(z, R::Ray)\n\nDetermine whether the number z lies \"to the right\" of ray R. This means that the angle it makes with tangent(R) is in the interval (-π,0).\n\nNote that isleft and isright are not logical opposites; a point on the (extended) ray should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.isright-Tuple{Number, Segment}","page":"API Reference","title":"ComplexRegions.isright","text":"isright(z,S::Segment)\n\nDetermine whether the number z lies \"to the right\" of segment S. This means that the angle it makes with tangent(S) is in the interval (-π,0).\n\nNote that isleft and isright are not logical opposites; a point on the (extended) segment should give false in both cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.n_gon-Tuple{Integer}","page":"API Reference","title":"ComplexRegions.n_gon","text":"n_gon(n)\n\nConstruct a regular n-gon with vertices on the unit circle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.normal-Tuple{ComplexRegions.AbstractCurve, Real}","page":"API Reference","title":"ComplexRegions.normal","text":"normal(C::AbstractCurve,t::Real)\n\nFind the unit complex number in the direction of the leftward-pointing normal to curve C at parameter value t in [0,1].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.normal-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath{T}, Real}} where T","page":"API Reference","title":"ComplexRegions.normal","text":"normal(P::AbstractPath,t::Real)\n\nCompute a complex-valued normal to path P at parameter value t. Values of t in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of t.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.point-Tuple{ComplexRegions.AbstractCurve, Real}","page":"API Reference","title":"ComplexRegions.point","text":"point(C::AbstractCurve,t::Real)\n\nFind the point on curve C at parameter value t, which should lie in the interval [0,1].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.point-Tuple{ComplexRegions.AbstractPath, AbstractArray{<:Real}}","page":"API Reference","title":"ComplexRegions.point","text":"point(P::AbstractPath, t::Real)\nP(t)\n\nCompute the point along path P at parameter value t. Values of t in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1.\n\npoint(P::AbstractPath, t::AbstractVector)\n\nVectorize the point method for path P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractCurve, AbstractArray{T}}} where T<:Real","page":"API Reference","title":"ComplexRegions.point","text":"point(C::AbstractCurve, t::AbstractArray)\n\nVectorize the point function for curve C.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.rectangle-Tuple{AbstractVector, AbstractVector}","page":"API Reference","title":"ComplexRegions.rectangle","text":"rectangle(xlim, ylim)\n\nConstruct the rectangle defined by xlim[1] < Re(z) < xlim[2], ylim[1] < Im(z) < ylim[2].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.rectangle-Tuple{AbstractVector{<:Number}}","page":"API Reference","title":"ComplexRegions.rectangle","text":"rectangle(v)\n\nConstruct the rectangle with vertices given in the vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.rectangle-Tuple{Union{Complex{S}, Polar{S}, Spherical{S}} where S<:AbstractFloat, Union{Complex{S}, Polar{S}, Spherical{S}} where S<:AbstractFloat}","page":"API Reference","title":"ComplexRegions.rectangle","text":"rectangle(z1, z2)\n\nConstruct the axes-aligned rectangle whose opposing corners are the given complex values.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.reflect-Tuple{Number, Circle}","page":"API Reference","title":"ComplexRegions.reflect","text":"reflect(z,C::Circle)\n\nReflect the value z across the circle C. (For reflection of a circle through a point, use translation and negation.)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.reflect-Tuple{Number, Line}","page":"API Reference","title":"ComplexRegions.reflect","text":"reflect(z, L::Line)\n\nReflect the value z across the line L. (For reflection of a line through a point, use translation and negation.)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.reflect-Tuple{Number, Segment}","page":"API Reference","title":"ComplexRegions.reflect","text":"reflect(z,S::Segment)\n\nReflect the value z across the extension of segment S to a line. (For reflection of a segment through a point, use translation and negation.)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.tangent-Tuple{ComplexRegions.AbstractCurve, Real}","page":"API Reference","title":"ComplexRegions.tangent","text":"tangent(C::AbstractCurve,t::Real)\n\nFind the complex number representing the tangent to curve C at parameter value t in [0,1].\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.tangent-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath{T}, Real}} where T","page":"API Reference","title":"ComplexRegions.tangent","text":"tangent(P::AbstractPath,t::Real)\n\nCompute the complex-valued tangent along path P at parameter value t. Values of t in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of t.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractCurve, Real}","page":"API Reference","title":"ComplexRegions.unittangent","text":"unittangent(C::AbstractCurve, t::Real)\n\nFind the complex number representing the unit tangent to curve C at parameter value t in [0,1]. For Lines, Segments, and Rays, the t argument is optional.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.unittangent-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath{T}, Real}} where T","page":"API Reference","title":"ComplexRegions.unittangent","text":"unittangent(P::AbstractPath,t::Real)\n\nCompute the complex-valued unit tangent along path P at parameter value t. Values of t in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of t.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractClosedPath, Integer}","page":"API Reference","title":"ComplexRegions.vertex","text":"vertex(P::AbstractPath,k::Integer)\n\nReturn the kth vertex of the path P. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first vertex.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractPath, Integer}","page":"API Reference","title":"ComplexRegions.vertex","text":"vertex(P::AbstractPath,k::Integer)\n\nReturn the kth vertex of the path P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractClosedPath}","page":"API Reference","title":"ComplexRegions.vertices","text":"vertices(P::AbstractClosedPath)\n\nReturn an array of the unique vertices (endpoints of the curves) of the closed path P. The length is equal the number of curves in P, i.e., the first/last vertex is not duplicated.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractPath}","page":"API Reference","title":"ComplexRegions.vertices","text":"vertices(P::AbstractPath)\n\nReturn an array of the vertices (endpoints of the curves) of the path P. The length is one greater than the number of curves in P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.winding-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}","page":"API Reference","title":"ComplexRegions.winding","text":"winding(P,z)\n\nCompute the winding number of a closed curve or path P about the point z. Each counterclockwise rotation about z contributes +1, and each clockwise rotation about it counts -1. The winding number is zero for points not in the region enclosed by P. \n\nThe result is unreliable for points lying on P, for which the problem is ill-posed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Other-functions","page":"API Reference","title":"Other functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ComplexRegions]\nPrivate = true\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api/#Base.:+-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}","page":"API Reference","title":"Base.:+","text":"X + z\nz + X\n\nTranslate a curve, path, or region X by a complex number z. \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Number, Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}","page":"API Reference","title":"Base.:-","text":"z - X\n\nNegate a curve, path, or region X (reflect through the origin) and translate by z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}, Number}","page":"API Reference","title":"Base.:-","text":"X - z\n\nTranslate a curve, path, or region X by a number -z.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}","page":"API Reference","title":"Base.:-","text":"-X\n\nNegate a curve, path, or region X (reflect through the origin).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isreal-Tuple{ComplexRegions.AbstractPath}","page":"API Reference","title":"Base.isreal","text":"isreal(P::AbstractPath)\n\nReturn true if the path is entirely on the real axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.default-Tuple{}","page":"API Reference","title":"ComplexRegions.default","text":"ComplexRegions.default()\n\nReturn a dictionary of global default settings for the ComplexRegions package.\n\nComplexRegions.default(key=value)\n\nChange a global default setting in the running instance of the ComplexRegions package.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComplexRegions.quad-Tuple{Rectangle}","page":"API Reference","title":"ComplexRegions.quad","text":"quad(R::Rectangle)\n\nConstruct the rectangle interior to R.\n\n\n\n\n\n","category":"method"},{"location":"numbers/#Number-representations","page":"Number types","title":"Number representations","text":"","category":"section"},{"location":"numbers/","page":"Number types","title":"Number types","text":"using ComplexRegions","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"The package is designed to work with complex numbers in different formats, including the native Complex type and the Polar and Spherical types from the ComplexValues package. The package re-exports these types, so you can use them directly.","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"seg = Segment(0, Polar(3, π/4))\npoint(seg, (0:4)/4)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Complex.(ans)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"(The following feature was added most recently and may have rough edges. Please report any issues.)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"In addition, the package supports different floating-point types underlying any of the complex number types. This means you can use BigFloats or DoubleFloats to get higher precision.","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"using DoubleFloats\nseg = Segment{DoubleFloat}(-1, 1)\nseg(2//3)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Working in higher precision can be tricky: if you ever use a standard Float64 value, it will set a ceiling on the precision of the result. For example, the following code will not give you the expected result:","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"seg(2/3)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"As above, you can use Rational types to avoid premature floating-point conversion, or perform the conversions prior to calls:","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"seg(DoubleFloat(2) / 3)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Naturally, though, many powers of two can be converted correctly into higher precision without loss:","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"seg(1//8) - seg(0.125)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Curves, paths, and regions can be constructed with an explicit AbstractFloat type in braces. If the type is not given, the constructor will use the highest precision of its arguments, or default to Float64 if the inputs are integers or rationals.","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"setprecision(100)\ncir = Circle(BigFloat(1) / 5, 1//5)","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Again, note the effect of premature float casting:","category":"page"},{"location":"numbers/","page":"Number types","title":"Number types","text":"Circle(BigFloat(1) / 5, 1/5)","category":"page"},{"location":"paths/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"A path is a sequence of curves that compose a continuous complex-valued path.","category":"page"},{"location":"paths/#interface_paths","page":"Paths","title":"Abstract interface","text":"","category":"section"},{"location":"paths/#AbstractPath","page":"Paths","title":"AbstractPath","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"Every AbstractPath type is expected to provide the following method:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"curves(P): Return an array of the curves constituting P.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"In addition, default implementations are given for the following methods.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Method Description\ncurve(P, k::Integer) kth curve of P.\nvertices(P) Vertices of P (the endpoints of the constituent curves)\nvertex(P, k::Integer) kth vertex of P.\nlength(P) Number of curves in the path.\nisfinite(P) True if the path is bounded.\npoint(P, t::Real) Point on the path.\npoint(P, t::AbstractVector) Vectorization of point.\ntangent(P, t::Real) Complex-valued tangent at a point.\nunittangent(P, t::Real) Normalized tangent at a point.\nnormal(P, t::Real) Leftward-pointing unit normal at a point.\nconj(P) Complex conjugate of the path.\nreverse(P) Reverse the orientation of the path.\n+,-,*,/ Translate, rotate and scale a path.\nisapprox(P1, P2) Determine whether two values represent the same path.\narclength(P) Arc length of the path.\ndist(z, P) Distance from a point to the path.\nclosest(z, P) Point on the path nearest to a given number.","category":"page"},{"location":"paths/#Iterator-interface","page":"Paths","title":"Iterator interface","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"The AbstractPath type implements the eltype, length, getindex, and iterate methods of the standard Julia iterator interface. Therefore, clauses such as for c in P will iterate over the curves in P for loops, comprehensions, and generators.","category":"page"},{"location":"paths/#AbstractClosedPath","page":"Paths","title":"AbstractClosedPath","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"The AbstractClosedPath subtype modifies a few of the implementations above:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Method Description\nvertices(P) Only the unique vertices; i.e., does not duplicate the initial/final vertex.\ncurve(P, k) kth curve of the path in a circular/modulo sense.\nvertex(P, k) kth vertex of the path in a circular/modulo sense.\npoint, tangent, unittangent, normal Use a circular/modulo interpretation of the parameter.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"The AbstractClosedPath type also has default implementations for the following methods:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Method Description\nwinding(P, z) Winding number of P about z.\nisinside(z, P) Detect whether z lies inside the path.\nisoutside(z, C) Detect whether z lies outside the path.","category":"page"},{"location":"paths/#Generic-types","page":"Paths","title":"Generic types","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"There are generic implementations of both of the abstract types described above.","category":"page"},{"location":"paths/#Path","page":"Paths","title":"Path","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"Path implements the AbstractPath type. A path is created by calling Path(c), where c is a vector of curves subtyped from AbstractCurve. The constructor tests the endpoints of the given curves for continuity up to a selectable tolerance.","category":"page"},{"location":"paths/#ClosedPath","page":"Paths","title":"ClosedPath","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"ClosedPath implements the AbstractClosedPath type. Its chief difference from the Path type is that the constructor also checks whether the initial and final points coincide (up to tolerance). As a subtype of AbstractClosedPath, this type also inherits the use of circular/modulo addressing for curve selection and parameterization.","category":"page"},{"location":"paths/#examples_paths","page":"Paths","title":"Examples","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"using ComplexRegions","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Here is a path defined by arcs and segments.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"a = Arc(-1, 1, -1im)\nright = Path([4 + 1im+a, 4-1im - 1im*a])\ns = Segment(-3+1im, 3+1im)\np = ClosedPath([s, right..., -s, -right...])\narclength(p)\nvertices(p)\n\nusing ComplexPlots, Plots\nplot(cispi(1/4) * p, label=\"bone\")\nsavefig(\"bone.svg\"); nothing # hide","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"(Image: dog-bone path)","category":"page"},{"location":"polygons/#Polygons","page":"Polygons","title":"Polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"There are two specialized implementations of the AbstractClosedPath type: CircularPolygon and the subtype Polygon, which implement the AbstractCircularPolygon and AbstractPolygon types, respectively.","category":"page"},{"location":"polygons/#CircularPolygon","page":"Polygons","title":"CircularPolygon","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"A CircularPolygon is a closed path whose curve components are all of type Arc, Ray, and Segment. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling CircularPolygon(c) with a vector or AbstractPath of curves of appropriate types; continuity and closure of the path are checked as necessary.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"In addition to the usual methods for a ClosedPath, the following are implemented:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Method Description\nside Alias for curve.\nwinding(P,z) Winding number of P relative to z.\ntruncate(P) Replace infinite sides with finite ones.","category":"page"},{"location":"polygons/#Polygon","page":"Polygons","title":"Polygon","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"A Polygon is a closed path whose curve components are all of type Ray and Segment. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling Polygon(c) with a vector or AbstractPath of curves of appropriate types; continuity and closure of the path are checked as necessary.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"An alternative construction is to provide a vector of vertices. In place of an infinite vertex, you can supply a tuple of the angles of the two rays that meet there. See the examples section below.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"In addition to the methods for the Abstract interface and CircularPolygon, the Polygon type offers","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Method Description\nangles(P) Interior angles of the polygon.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Angles at a finite vertex are in the interval (02pi, while angles at an infinite vertex are in -2pi0, representing the angle at the pole of the Riemann sphere.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Two additional special polygon constructors are defined:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Method Description\nrectangle(xlim,ylim) or rectangle(z1,z2) Construct an axes-aligned rectangle.\nn_gon(n) Construct a regular n-gon with unit vertices.","category":"page"},{"location":"polygons/#Examples","page":"Polygons","title":"Examples","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"using ComplexRegions","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"A big plus:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"box = [1-1im, 3-1im, 3+1im]\nplus = Polygon([box; 1im*box; -box; -1im*box])\n\nusing ComplexPlots, Plots\ndefault(linewidth=2,legend=false)\nplot(plus, color=:red)\nsavefig(\"plus.svg\"); nothing # hide","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"(Image: plus polygon)","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"A Koch snowflake:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"v = vertices(n_gon(3));\npattern = [1; (v .- v[1]) / (v[1] - v[3])/3 .+ 2/3 ];\nkoch(a,b) = b .+ (a - b) * pattern;\nfor m = 1:3\n\t@show n = length(v);\n\tglobal v = vcat( [koch(v[k], v[mod(k, n) + 1]) for k in 1:n]... );\nend\nplot(Polygon(v))\nsavefig(\"snowflake.svg\"); nothing # hide","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"(Image: snowflake polygon)","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Infinite channel with a step, using tuples to specify the angles of rays going to infinity:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"p = Polygon([0, -1im, (0,0), 1im, (pi,pi)])","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"plot(p, xlims=[-5,5], ylims=[-5,5])\nsavefig(\"channel.svg\"); nothing # hide","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"(Image: channel polygon)","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Infinite polygons can seem quite strange:","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"probe1 = [1, 0, 1im, -1im, 0];\nprobe2 = cispi(-3/4)*probe1 .- (3 + 2im);\nplot( Polygon([probe1...,(0, -3π/4), probe2..., (-3π/4, 0)]) )\nxlims!(-6, 6); ylims!(-6, 6)\nsavefig(\"probes.svg\"); nothing # hide","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"(Image: probes polygon)","category":"page"},{"location":"regions/#Regions","page":"Regions","title":"Regions","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"A region is the open set on one side of a closed curve or closed path.","category":"page"},{"location":"regions/#interface_regions","page":"Regions","title":"Abstract interface","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"An AbstractRegion is expected to provide the following methods. Here R is an AbstractRegion and z is a number.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Method Description\nboundary(R) Boundary curve(s)/path(s) of a region.\nin(z,R) Determine whether z is in R.\nisfinite(R) Determine whether the region is bounded.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"There are default implementations of the following methods.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Method Description\nintersect(R1,R2) or R1 ∩ R2 Intersection of two regions. (Currently a stub for further development.)\nunion(R1,R2) or R1 ∪ R2 Union of two regions. (Currently a stub for further development.)","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"There is also a parametric subtype AbstractConnectedRegion{N} used to represent a region of connectivity N. Any implementation is expected to provide the following methods.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Method Description\nouterboundary(R) Curve/path of the outermost boundary, if it exists.\ninnerboundary(R) Curve(s)/path(s) of inner boundaries (that R is exterior to).","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Default implementations are provided for  +, -, *, /, performing translation, rotation, and scaling.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"AbstractSimplyConnectedRegion is an alias for AbstractConnectedRegion{1}.","category":"page"},{"location":"regions/#Generic-types","page":"Regions","title":"Generic types","text":"","category":"section"},{"location":"regions/#SimplyConnectedRegion","page":"Regions","title":"SimplyConnectedRegion","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"Type SimplyConnectedRegion is a union of parameterized types InteriorSimplyConnectedRegion{T} and ExteriorSimplyConnectedRegion{T}, where T is a subtype of a union of AbstractClosedCurve and AbstractClosedPath. The preferred method for constructing a value of one of these types is to use interior and exterior, respectively, with a closed curve or path as argument. If the given curve is bounded, these constructors ignore its orientation and select the bounded or unbounded region it defines, respectively. For an unbounded boundary curve, points \"to the left\" of it are considered the interior.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"In addition to the methods of the Abstract interface, the  SimplyConnectedRegion type provides the following methods.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Method Description\n!(R) Complement of R.\nisapprox(R1, R2) Determine whether R1 and R2 represent the same region.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"The SimplyConnectedRegion type is parameterized by the type of curve bounding it in order to facilitate dispatch. Notably included are the definitions","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"AbstractDisk = SimplyConnectedRegion{T} where T<:Circle\nAbstractHalfplane = SimplyConnectedRegion{T} where T<:Line\nPolygonalRegion = SimplyConnectedRegion{Polygon}","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"There are also methods to facilitate construction of important common regions. For disks there are","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"disk(C::Circle)\ndisk(center, radius)\nunitdisk","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"For half-planes there are","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"halfplane(L::Line)\nupperhalfplane\nlowerhalfplane\nlefthalfplane\nrighthalfplane","category":"page"},{"location":"regions/#ExteriorRegion","page":"Regions","title":"ExteriorRegion","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"The parameterized type ExteriorRegion{N} represents a region lying exterior to N closed curves or paths. It is constructed by ExteriorRegion(inner), where inner is a vector of closed curves/paths. These are returned by innerboundary, and outerboundary returns nothing.","category":"page"},{"location":"regions/#ConnectedRegion","page":"Regions","title":"ConnectedRegion","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"The parameterized type ConnectedRegion{N} represents a region of connectivity N. You construct one by calling ConnectedRegion{N}(outer, inner), where outer (if given) is an outer boundary, possibly unbounded, and inner is a vector of disconnected inner boundary components. Some rudimentary checking is done that a valid region of connectivity N has been specified, but it should not be considered rigorous.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"The particular case of a doubly connected region can be constructed by between(outer, inner), giving the two boundary components. The given orientation is ignored for any bounded component.","category":"page"},{"location":"regions/#subtypes_regions","page":"Regions","title":"Specific subtypes","text":"","category":"section"},{"location":"regions/#Annulus","page":"Regions","title":"Annulus","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"An Annulus is the doubly connected region between two concentric circles. It is a subtype of AbstractConnectedRegion{2}. Construction is by Annulus(outer, inner), where Circle values  are given explicitly, or by Annulus(outrad, inrad, center=0), giving the radii and optionally the center.","category":"page"},{"location":"regions/#Examples","page":"Regions","title":"Examples","text":"","category":"section"},{"location":"regions/","page":"Regions","title":"Regions","text":"using ComplexRegions","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Here is a \"dog bone\" region.","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"a = Arc(-1,1,-1im);\nright = Path([4+1im+a,4-1im-1im*a]);\ns = Segment(-3+1im,3+1im);\np = ClosedPath([s,right...,-s,-right...]);\nr = interior(exp(1im*pi/4)*p)\n\nusing ComplexPlots, Plots\ndefault(linewidth=2,legend=:none)\nplot(r)\nsavefig(\"bone-region.svg\"); nothing # hide","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"(Image: dog-bone region)","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"Are you inspired by the Swiss flag?","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"box = [1-1im, 3-1im, 3+1im];\nplus = Polygon([box; 1im*box; -box; -1im*box]);\nr = between(rectangle(-6-4im, 6+4im), plus)\nplot(r, color=:red, linewidth=0)\nsavefig(\"swiss.svg\"); nothing # hide","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"(Image: Swiss flag)","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"A multiply-connected exterior region:","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"c = Circle(0, 1)\nt = n_gon(3)\ns = n_gon(4)\nplot( ExteriorRegion([c, 3+s, 6+t]) )\nsavefig(\"triple.svg\"); nothing # hide","category":"page"},{"location":"regions/","page":"Regions","title":"Regions","text":"(Image: 3-connected region)","category":"page"},{"location":"shapes/#Predefined-shapes","page":"Shapes","title":"Predefined shapes","text":"","category":"section"},{"location":"shapes/","page":"Shapes","title":"Shapes","text":"using ComplexRegions","category":"page"},{"location":"shapes/","page":"Shapes","title":"Shapes","text":"The Shapes submodule provides a number of predefined shapes that can be used in constructing regions. ","category":"page"},{"location":"shapes/","page":"Shapes","title":"Shapes","text":"using ComplexPlots, Plots\nshapes = [\n    Shapes.circle  Shapes.ellipse(2, 1) Shapes.squircle; \n    Shapes.square  Shapes.triangle      Shapes.cross;\n    Shapes.hypo(3) Shapes.star          Shapes.spiral(2, 0.7)\n    ]\n\nfig = plot(resolution=(400, 400), layout=(3,3), showaxis=false, legend=false)\nfor i in 1:3, j in 1:3\n    plot!(shapes[i, j], l=2, subplot=3i + j - 3, aspect_ratio=1, guide=\"\", grid=false)\nend\nsavefig(\"shapes.svg\"); nothing # hide","category":"page"},{"location":"shapes/","page":"Shapes","title":"Shapes","text":"(Image: table of shapes)","category":"page"},{"location":"#ComplexRegions","page":"Introduction","title":"ComplexRegions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using ComplexRegions","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides types and methods that are useful for working with curves and regions in the (extended) complex plane.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note: Starting in version 0.2, plot capabilities have been moved to the ComplexPlots package. Some of these are still used here to illustrate the examples.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Most functionality is provided through Julia types. Per Julia conventions, these are all capitalized. You use these capitalized names to create values of the type; e.g., Segment and Circle.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other methods may create values of these types, but since they are not distinct types themselves, they are not capitalized. For example, the rectangle method creates a Polygon.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methods in this package should work not only with the built-in Complex type, but also with the Polar and Spherical types from the ComplexValues package, which it re-exports.","category":"page"},{"location":"#Abstract-vs-concrete-types","page":"Introduction","title":"Abstract vs concrete types","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"All abstract types have names starting with Abstract. You probably won't encounter them unless you want to extend the provided functionality.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Abstract types cannot be instantiated. They serve as supertypes that collect common-denominator functionality, much like an interface or abstract class does in some object-oriented languages. Only the concrete descendants of these abstract types can be instantiated.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For example, any AbstractCurve is supposed to implement functions for finding points, tangents, and normals along the curve. There is a generic concrete Curve type that does the minimum required.  Specific subtypes such as a Ray or Arc provide (considerable) additional specialized functionalities appropriate to the subtypes.","category":"page"},{"location":"#Curve,-Path,-and-Region","page":"Introduction","title":"Curve, Path, and Region","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A curve is meant to be a smooth, non-self-intersecting curve in the extended complex plane. The generic Curve type requires you to specify an explicit parameterization that is not checked for smoothness or even continuity. It will use automatic differentiation to find a tangent, if no tangent function is supplied. Particular subtypes of curve are Circle, Arc, Line, Ray, and Segment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A path is a piecewise-continuous complex-valued path. In practice a Path can be specified as a vector of curves. The path is checked for continuity at creation time. The most important provided specific path types are Polygon and CircularPolygon.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Both curves and paths have closed variants. These are additionally checked at creation to ensure that the initial and final points are the same.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"One atypical aspect of curves and paths, even \"closed\" ones, is that they lie in the extended or compactified complex plane and thus may be unbounded. For instance, a line in the plane may be interpreted as a circle on the Riemann sphere, and is thus a closed curve passing through infinity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, a region is an open region in the extended plane bounded by a closed curve or path.","category":"page"},{"location":"#Tolerance","page":"Introduction","title":"Tolerance","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Boundaries and endpoints are not well-posed ideas in floating-point, since an arbitrarily small perturbation to a value can move a point on or off of them. Thus many concepts in the package such as intersection or continuity are checked only up to a small tolerance. This value defaults to a modest multiple of machine precision and can be overridden on a per-call basis.","category":"page"},{"location":"intersections/#Intersections","page":"Intersections","title":"Intersections","text":"","category":"section"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"Methods are provided to find intersections between all the Specific subtypes. In the generic cases where the intersections consist of zero or more points, a vector of results is returned. In special circumstances of partially or wholly overlapping curves, a Curve subtype is returned.","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"There are also methods for finding the intersections between curves and paths, and between two paths. These return set unions over the curves of the path(s), returning a vector with complex element type or, if some overlaps occurred, mixed types.","category":"page"},{"location":"intersections/#examples_intersections","page":"Intersections","title":"Examples","text":"","category":"section"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"using ComplexRegions","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"Circles and Arcs intersect at zero, one, or two points, or as an Arc.","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"c = Circle(0, 1)\na = Arc(1+1im, 0, 1-1im)\nintersect(c, a)\nb = Arc(1im, 1, -1im)\nintersect(c, b)\nans ≈ b","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"Segments and Lines intersect at zero or one point, or as a Line or Segment.","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"l = Line(1im, 1+1im)\ns = Segment(-2, 2+2im)\nintersect(l, s)\nintersect(l, s + 2im)\nintersect(s,Segment(-4-1im, 1im))","category":"page"},{"location":"intersections/","page":"Intersections","title":"Intersections","text":"ℓ = Line(1/2, 1/2+1im)  # line through 0.5 and 0.5+1i\nc = 1 / ℓ          # a circle\nintersect(ℓ, c)","category":"page"}]
}
