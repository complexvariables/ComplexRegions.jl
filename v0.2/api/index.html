<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · ComplexRegions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ComplexRegions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../curves/">Curves</a></li><li><a class="toctext" href="../paths/">Paths</a></li><li><a class="toctext" href="../polygons/">Polygons</a></li><li><a class="toctext" href="../intersections/">Intersections</a></li><li><a class="toctext" href="../regions/">Regions</a></li><li><a class="toctext" href="../mobius/">Möbius</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"><li><a class="toctext" href="#Exported-types-1">Exported types</a></li><li><a class="toctext" href="#Exported-functions-1">Exported functions</a></li><li><a class="toctext" href="#Other-functions-1">Other functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul><a class="edit-page" href="https://github.com//blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Exported-types-1" href="#Exported-types-1">Exported types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Annulus" href="#ComplexRegions.Annulus"><code>ComplexRegions.Annulus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Annulus</code></pre><p>Representation of the region between two circles.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Annulus" href="#ComplexRegions.Annulus"><code>ComplexRegions.Annulus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Annulus(radouter,radinner)
Annulus(radouter,radinner,center)</code></pre><p>Construct a concentric annulus of outer radius <code>radouter</code> and inner radius <code>radinner</code> centered at <code>center</code>. If the center is not given, the origin is used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Arc" href="#ComplexRegions.Arc"><code>ComplexRegions.Arc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Arc{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Arc</code> type is parameterized according to the common type of its complex input arguments. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Arc-Union{Tuple{T}, Tuple{Circle{T},Real,Real}} where T&lt;:(Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat)" href="#ComplexRegions.Arc-Union{Tuple{T}, Tuple{Circle{T},Real,Real}} where T&lt;:(Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat)"><code>ComplexRegions.Arc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Arc(C,start,delta)</code></pre><p>Consruct an arc that is the part of the Circle <code>C</code> starting at parameter value <code>start</code> and ending at <code>start+delta</code>. The values are expressed in terms of fractions of a complete circle. The <code>start</code> value should be in [0,1), and <code>delta</code> should be in [-1,1].</p><pre><code class="language-none">Arc(a,b,c)</code></pre><p>Construct the arc starting at point <code>a</code>, passing through <code>b</code>, and ending at <code>c</code>. If the three points are collinear, a <code>Segment</code> is returned instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Circle" href="#ComplexRegions.Circle"><code>ComplexRegions.Circle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Circle{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Circle</code> type is parameterized according to the common type of its complex input arguments. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Circle" href="#ComplexRegions.Circle"><code>ComplexRegions.Circle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Circle(zc,r,ccw=true)</code></pre><p>Construct the circle with given center <code>zc</code>, radius <code>r</code>, and orientation (defaults to counterclockwise).</p><pre><code class="language-none">Circle(a,b,c)</code></pre><p>Construct the circle passing through the given three numbers. Orientation is determined so that the values are visited in the given order. If the three points are collinear (including when one of the given values is infinite), a <code>Line</code> is returned instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.CircularPolygon" href="#ComplexRegions.CircularPolygon"><code>ComplexRegions.CircularPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) CircularPolygon</code></pre><p>Type for closed paths consisting entirely of arcs, segments, and rays. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.CircularPolygon-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.CircularPolygon-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.CircularPolygon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CircularPolygon(p::AbstractPath; tol=&lt;default&gt;) 
CircularPolygon(p::AbstractVector; tol=&lt;default&gt;)</code></pre><p>Construct a circular polygon from a (possibly closed) path, or from a vector of curves. The <code>tol</code> parameter is a tolerance used when checking continuity and closedness of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ClosedCurve" href="#ComplexRegions.ClosedCurve"><code>ComplexRegions.ClosedCurve</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>(type) Smooth closed curve defined by an explicit function of a real paramerter in [0,1]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ClosedCurve" href="#ComplexRegions.ClosedCurve"><code>ComplexRegions.ClosedCurve</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClosedCurve(f; tol=&lt;default&gt;)
ClosedCurve(f,a,b; tol=&lt;default)</code></pre><p>Construct a <code>ClosedCurve</code> object from the complex-valued function <code>point</code> accepting an argument in the interval [0,1]. The constructor checks whether <code>f(0)≈f(1)</code> to tolerance <code>tol</code>. If <code>a</code> and <code>b</code> are given, they are the limits of the parameter in the call to the supplied <code>f</code>. However, the resulting object will be defined on [0,1], which is internally scaled to [a,b].</p><pre><code class="language-none">ClosedCurve(f,df[,a,b]; tol=&lt;default&gt;)</code></pre><p>Construct a closed curve with point location and tangent given by the complex-valued functions <code>f</code> and <code>df</code>, respectively, optionally with given limits on the parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ClosedPath" href="#ComplexRegions.ClosedPath"><code>ComplexRegions.ClosedPath</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) ClosedPath</code></pre><p>Generic implementation of an <code>AbstractClosedPath</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ClosedPath-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexRegions.ClosedPath-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexRegions.ClosedPath</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ClosedPath(c::AbstractVector; tol=&lt;default&gt;)
ClosedPath(P::Path; tol=&lt;default&gt;)</code></pre><p>Given a vector <code>c</code> of curves, or an existing path, construct a closed path. The path is checked for continuity (to tolerance <code>tol</code>) at all of the vertices. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ConnectedRegion" href="#ComplexRegions.ConnectedRegion"><code>ComplexRegions.ConnectedRegion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) ConnectedRegion{N}</code></pre><p>Representation of a <code>N</code>-connected region in the extended complex plane. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ConnectedRegion-Tuple{Any,Any}" href="#ComplexRegions.ConnectedRegion-Tuple{Any,Any}"><code>ComplexRegions.ConnectedRegion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ConnectedRegion(outer,inner)</code></pre><p>Construct an open connected region by specifying its boundary components. The <code>outer</code> boundary could be <code>nothing</code> or a closed curve or path. The <code>inner</code> boundary should be a vector of one or more nonintersecting closed curves or paths. The defined region is interior to the outer boundary and exterior to all the components of the inner boundary, regardless of the orientations of the given curves. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Curve" href="#ComplexRegions.Curve"><code>ComplexRegions.Curve</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>(type) Smooth curve defined by an explicit function of a real paramerter in [0,1]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Curve-Tuple{Any}" href="#ComplexRegions.Curve-Tuple{Any}"><code>ComplexRegions.Curve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Curve(f)
Curve(f,a,b)</code></pre><p>Construct a <code>Curve</code> object from the complex-valued function <code>f</code> accepting an argument in the interval [0,1]. If <code>a</code> and <code>b</code> are given, they are the limits of the parameter in the call to the supplied <code>f</code>. However, the resulting object will be defined on [0,1], which is internally scaled to [a,b].</p><pre><code class="language-none">Curve(f,df[,a,b])</code></pre><p>Construct a curve with point location and tangent given by the complex-valued functions <code>f</code> and <code>df</code>, respectively, optionally with given limits on the parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Line" href="#ComplexRegions.Line"><code>ComplexRegions.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Line{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Line</code> type is parameterized according to the common type of its complex input arguments. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Line-Tuple{Number,Number}" href="#ComplexRegions.Line-Tuple{Number,Number}"><code>ComplexRegions.Line</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Line(a,b)</code></pre><p>Construct the line passing through the two given points. </p><pre><code class="language-none">Line(a,direction=z)</code></pre><p>Construct the line through the given point and parallel to the complex sign of the given <code>direction</code> value. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius" href="#ComplexRegions.Möbius"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Möbius</code></pre><p>Representation of a Möbius or bilinear transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-NTuple{4,Number}" href="#ComplexRegions.Möbius-NTuple{4,Number}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Möbius(a,b,c,d)</code></pre><p>Construct the <code>Möbius</code> map <span>$z ↦ (az+b)/(cz+d)$</span> by giving its coefficients. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#ComplexRegions.Möbius-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Möbius(z::AbstractVector,w::AbstractVector)</code></pre><p>Construct the <code>Möbius</code> map that transforms the points <code>z[k]</code> to <code>w[k]</code> for k=1,2,3.  Values of <code>Inf</code> are permitted in both vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{AbstractArray{T,2} where T}" href="#ComplexRegions.Möbius-Tuple{AbstractArray{T,2} where T}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Möbius(A::AbstractMatrix)</code></pre><p>Construct the <code>Möbius</code> map <span>$z ↦ (az+b)/(cz+d)$</span> by giving a matrix <code>A==[a b;c d]</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Number}" href="#ComplexRegions.Möbius-Tuple{Number}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">f(z::Number)</code></pre><p>Evaluate the <code>Möbius</code> map <code>f</code> at a real or complex value <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Arc, Segment}}" href="#ComplexRegions.Möbius-Tuple{Union{Arc, Segment}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">f(C::Union{Arc,Segment})</code></pre><p>Find the image of the arc or segment <code>C</code> under the <code>Möbius</code> map <code>f</code>. The result is also either an <code>Arc</code> or a <code>Segment</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Circle, Line},Union{Circle, Line}}" href="#ComplexRegions.Möbius-Tuple{Union{Circle, Line},Union{Circle, Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Möbius(C1,C2)</code></pre><p>Construct a <code>Möbius</code> map that transforms the curve <code>C1</code> to <code>C2</code>. Both curves must be either a <code>Line</code> or <code>Circle</code>. (These maps are not uniquely determined.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Circle, Line}}" href="#ComplexRegions.Möbius-Tuple{Union{Circle, Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">f(C::Union{Circle,Line})</code></pre><p>Find the image of the circle or line <code>C</code> under the <code>Möbius</code> map <code>f</code>. The result is also either a <code>Circle</code> or a <code>Line</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Möbius-Tuple{Union{Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Circle, Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Line}}" href="#ComplexRegions.Möbius-Tuple{Union{Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Circle, Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Line}}"><code>ComplexRegions.Möbius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">f(R::Union{AbstractDisk,AbstractHalfplane})</code></pre><p>If <code>R</code> is an <code>AbstractDisk</code> or an <code>AbstractHalfplane</code>, find its image under the <code>Möbius</code> map <code>f</code>. The result is also either an <code>AbstractDisk</code> or an <code>AbstractHalfplane</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f = Möbius(Line(-1,1),Circle(0,1))
Möbius transformation:

   (1.0 + 0.9999999999999999im) z + (3.666666666666666 - 1.666666666666667im)
   ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
   (1.0 + 0.9999999999999999im) z + (-1.666666666666666 + 3.6666666666666665im)

julia&gt; f(upperhalfplane)
Disk interior to:
   Circle(-5.55112e-17+2.22045e-16im,1.0)

julia&gt; isapprox(ans,unitdisk)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Path" href="#ComplexRegions.Path"><code>ComplexRegions.Path</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Path</code></pre><p>Generic implementation of an <code>AbstractPath</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Path-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexRegions.Path-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexRegions.Path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Path(c::AbstractVector; tol=&lt;default&gt;)</code></pre><p>Given a vector <code>c</code> of curves, construct a path. The path is checked for continuity (to tolerance <code>tol</code>) at the interior vertices. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Polygon" href="#ComplexRegions.Polygon"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Polygon</code></pre><p>Type for closed paths consisting entirely of segments and rays. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Polygon-Tuple{AbstractArray{T,1} where T}" href="#ComplexRegions.Polygon-Tuple{AbstractArray{T,1} where T}"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Polygon(v::AbstractVector)</code></pre><p>Construct a polygon from a vector of its vertices. Each element of <code>v</code> should be either a finite vertex, or a tuple of two angles that indicate the angles of two rays incident to an infinite vertex: one &quot;to&quot; infinity, and a second &quot;from&quot; infinity.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Polygon-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.Polygon-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.Polygon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Polygon(p::AbstractPath; tol=&lt;default&gt;) 
Polygon(p::AbstractVector{T&lt;:AbstractCurve}; tol=&lt;default&gt;)</code></pre><p>Construct a polygon from a (possibly closed) path, or from a vector of curves. The <code>tol</code> parameter is a tolerance used when checking continuity and closedness of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Ray" href="#ComplexRegions.Ray"><code>ComplexRegions.Ray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Ray{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Ray</code> type is parameterized according to the common type of its complex input arguments. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Ray" href="#ComplexRegions.Ray"><code>ComplexRegions.Ray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ray(a,θ,reverse=false)</code></pre><p>Construct the ray starting at <code>a</code> and extending to infinity at the angle <code>θ</code>. If <code>reverse</code> is true, the ray is considered to extend from infinity to <code>a</code> at angle <code>-θ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.RegionIntersection" href="#ComplexRegions.RegionIntersection"><code>ComplexRegions.RegionIntersection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) RegionIntersection</code></pre><p>Representation of the intersection of two regions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.RegionUnion" href="#ComplexRegions.RegionUnion"><code>ComplexRegions.RegionUnion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) RegionUnion</code></pre><p>Representation of the union of two regions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Segment" href="#ComplexRegions.Segment"><code>ComplexRegions.Segment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(type) Segment{T&lt;:AnyComplex} in the complex plane</code></pre><p>Each <code>Segment</code> type is parameterized according to the common type of its complex input arguments. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.Segment-Tuple{Number,Number}" href="#ComplexRegions.Segment-Tuple{Number,Number}"><code>ComplexRegions.Segment</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Segment(a,b)</code></pre><p>Consruct a segment that starts at value <code>a</code> and ends at <code>b</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexValues.Polar-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexValues.Polar-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexValues.Polar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Polar(::AbstractCurve)</code></pre><p>Interpret a curve as having points of type Polar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexValues.Spherical-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexValues.Spherical-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexValues.Spherical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Spherical(::AbstractCurve)</code></pre><p>Interpret a curve as having points of type Spherical.</p></div></div></section><h2><a class="nav-anchor" id="Exported-functions-1" href="#Exported-functions-1">Exported functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!-Tuple{ComplexRegions.InteriorSimplyConnectedRegion}" href="#Base.:!-Tuple{ComplexRegions.InteriorSimplyConnectedRegion}"><code>Base.:!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">!(R::SimplyConnectedRegion)</code></pre><p>Compute the region complementary to <code>R</code>. This is not quite set complementation, as neither region includes its boundary. The complement is always simply connected in the extended plane. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:+-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">X + z
z + X</code></pre><p>Translate a curve, path, or region <code>X</code> by a complex number <code>z</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Number,Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:--Tuple{Number,Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">z - X</code></pre><p>Negate a curve, path, or region <code>X</code> (reflect through the origin) and translate by <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion},Number}" href="#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion},Number}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">X - z</code></pre><p>Translate a curve, path, or region <code>X</code> by a number <code>-z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.:--Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">-X</code></pre><p>Negate a curve, path, or region <code>X</code> (reflect through the origin).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∘-Tuple{Möbius,Möbius}" href="#Base.:∘-Tuple{Möbius,Möbius}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∘(f::Möbius,g::Möbius)</code></pre><p>Compose two <code>Möbius</code> transformations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.conj-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">conj(X)</code></pre><p>Construct the complex conjugate of curve, path, or region <code>X</code>. (Reverses the orientation of a curve or path.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{Number,ComplexRegions.AbstractRegion}" href="#Base.in-Tuple{Number,ComplexRegions.AbstractRegion}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">in(z::Number,R::AbstractRegion;tol=&lt;default&gt;)
z ∈ R   (type &quot;\in&quot; followed by tab)</code></pre><p>True if <code>z</code> is in the region <code>R</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">intersect(c1::AbstractCurve,c2::AbstractCurve; tol=&lt;default&gt;)</code></pre><p>Find the intersection(s) of two curves. The result could be a vector of zero or more values, or a curve. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect-Tuple{ComplexRegions.AbstractRegion,ComplexRegions.AbstractRegion}" href="#Base.intersect-Tuple{ComplexRegions.AbstractRegion,ComplexRegions.AbstractRegion}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">intersect(R1::AbstractRegion,R2::AbstractRegion)
R1 ∩ R2    (type &quot;\cap&quot; followed by tab key)</code></pre><p>Create the region that is the intersection of <code>R1</code> and <code>R2</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Arc}" href="#Base.inv-Tuple{Arc}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(A)</code></pre><p>Invert the arc <code>A</code> through the origin. In general the inverse is an <code>Arc</code>, though the result is a <code>Segment</code> if the arc&#39;s circle passes through the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Circle}" href="#Base.inv-Tuple{Circle}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(C)</code></pre><p>Invert the circle <code>C</code> through the origin. In general the inverse is a <code>Circle</code>, though the result is a <code>Line</code> if <code>C</code> passes through the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Line}" href="#Base.inv-Tuple{Line}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(L)</code></pre><p>Invert a line <code>L</code> through the origin. In general the inverse is a <code>Circle</code> through the inverse of any three points on the line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Möbius}" href="#Base.inv-Tuple{Möbius}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(f::Möbius)</code></pre><p>Find the inverse of a <code>Möbius</code> transformation. This is the functional inverse, not 1/f(z). </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Ray}" href="#Base.inv-Tuple{Ray}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(R)</code></pre><p>Invert the ray <code>R</code> through the origin. In general the inverse is an <code>Arc</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Segment}" href="#Base.inv-Tuple{Segment}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(S)</code></pre><p>Invert the segment <code>S</code> through the origin. In general the inverse is an <code>Arc</code>, though the result is a <code>Segment</code> if <code>S</code> would pass through the origin when extended.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}" href="#Base.inv-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath, ComplexRegions.AbstractRegion}}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inv(X)</code></pre><p>Invert a curve, path, or region pointwise.	</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Arc,Arc}" href="#Base.isapprox-Tuple{Arc,Arc}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(A1::Arc,A2::Arc; tol=&lt;default&gt;) 
A1 ≈ A2</code></pre><p>Determine if <code>A1</code> and <code>A2</code> represent the same arc, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Circle,Circle}" href="#Base.isapprox-Tuple{Circle,Circle}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(C1::Circle,C2::Circle; tol=&lt;default&gt;) 
C1 ≈ C2</code></pre><p>Determine if <code>C1</code> and <code>C2</code> represent the same circle, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{ComplexRegions.AbstractPath,ComplexRegions.AbstractPath}" href="#Base.isapprox-Tuple{ComplexRegions.AbstractPath,ComplexRegions.AbstractPath}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(P1::AbstractPath,R2::AbstractPath; tol=&lt;default&gt;)
P1 ≈ P2       (type &quot;\approx&quot; followed by tab key)</code></pre><p>Determine whether <code>P1</code> and <code>P2</code> represent the same path, up to tolerance <code>tol</code>, irrespective of the parameterization of its curves.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Line,Line}" href="#Base.isapprox-Tuple{Line,Line}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(L1::Line,L2::Line; tol=&lt;default&gt;) 
L1 ≈ L2</code></pre><p>Determine if <code>L1</code> and <code>L2</code> represent the same line, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Ray,Ray}" href="#Base.isapprox-Tuple{Ray,Ray}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(R1::Ray,R2::Ray; tol=&lt;default&gt;) 
R1 ≈ R2</code></pre><p>Determine if <code>R1</code> and <code>R2</code> represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Segment,Segment}" href="#Base.isapprox-Tuple{Segment,Segment}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(S1::Segment,S2::Segment; tol=&lt;default&gt;) 
S1 ≈ S2</code></pre><p>Determine if <code>S1</code> and <code>S2</code> represent the same segment, irrespective of the type or values of its parameters. Identity is determined by agreement within <code>tol</code>, which is interpreted as the weaker of absolute and relative differences.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:(Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}) where S" href="#Base.isapprox-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:(Union{ComplexRegions.ExteriorSimplyConnectedRegion{T}, ComplexRegions.InteriorSimplyConnectedRegion{T}} where T&lt;:Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}) where S"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(R1::SimplyConnectedRegion,R2::SimplyConnectedRegion; tol=&lt;default&gt;)</code></pre><p>Determine whether <code>R1</code> and <code>R2</code> represent the same region, up to tolerance <code>tol</code>. Equivalently, determine whether their boundaries are the same.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractCurve}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractCurve}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isfinite(C::AbstractCurve)</code></pre><p>Return <code>true</code> if the curve is bounded in the complex plane (i.e., does not pass through infinity).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractPath}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractPath}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isfinite(P::AbstractPath)</code></pre><p>Return <code>true</code> if the path is bounded in the complex plane (i.e., does not pass through infinity).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isfinite-Tuple{ComplexRegions.AbstractRegion}" href="#Base.isfinite-Tuple{ComplexRegions.AbstractRegion}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isfinite(R::AbstractRegion)</code></pre><p>Return <code>true</code> if the region is bounded in the complex plane.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}" href="#Base.reverse-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reverse(X)</code></pre><p>Construct a curve or path identical to <code>X</code> except with opposite direction of parameterization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.truncate-Tuple{Union{CircularPolygon, Polygon},Circle}" href="#Base.truncate-Tuple{Union{CircularPolygon, Polygon},Circle}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">truncate(P::Union{CircularPolygon,Polygon},C::Circle)</code></pre><p>Compute a trucated form of the polygon by replacing each pair of rays incident at infinity with two segments connected by an arc along the given circle. This is <em>not</em> a true clipping of the polygon, as finite sides are not altered. The result is either a CircularPolygon or the original <code>P</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.truncate-Tuple{Union{CircularPolygon, Polygon}}" href="#Base.truncate-Tuple{Union{CircularPolygon, Polygon}}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">truncate(P::Union{CircularPolygon,Polygon})</code></pre><p>Apply <code>truncate</code> to <code>P</code> using a circle that is centered at the centroid of its finite vertices, and a radius twice the maximum from the centroid to the finite vertices. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union-Tuple{ComplexRegions.AbstractRegion,ComplexRegions.AbstractRegion}" href="#Base.union-Tuple{ComplexRegions.AbstractRegion,ComplexRegions.AbstractRegion}"><code>Base.union</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">union(R1::AbstractRegion,R2::AbstractRegion)
R1 ∪ R2    (type &quot;\cup&quot; followed by tab key)</code></pre><p>Create the region that is the union of <code>R1</code> and <code>R2</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.angles-Tuple{Polygon}" href="#ComplexRegions.angles-Tuple{Polygon}"><code>ComplexRegions.angles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">angles(P::Polygon)</code></pre><p>Compute a vector of interior angles at the vertices of the polygon <code>P</code>. At a finite vertex these lie in (0,2π]; at an infinite vertex, the angle is in [-2π,0]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arclength-Tuple{Path}" href="#ComplexRegions.arclength-Tuple{Path}"><code>ComplexRegions.arclength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arclength(P::Path)</code></pre><p>Compute the arclength of the path <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arclength-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}" href="#ComplexRegions.arclength-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}}"><code>ComplexRegions.arclength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arclength(X)</code></pre><p>Fetch or compute the arc length of the curve or path <code>X</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ellipse = ClosedCurve( t-&gt;cos(t)+2im*sin(t), 0,2π );
julia&gt; arclength(ellipse)  # good to about 10 digits
9.688448219981513</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Arc,Number}" href="#ComplexRegions.arg-Tuple{Arc,Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arg(A::Arc,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>A(t)==z</code> is true. </p><p>This gives undefined results if <code>z</code> is not actually on the arc. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Circle,Number}" href="#ComplexRegions.arg-Tuple{Circle,Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arg(C::Circle,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>C(t)==z</code> is true. </p><p>This gives undefined results if <code>z</code> is not actually on the circle. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Line,Number}" href="#ComplexRegions.arg-Tuple{Line,Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arg(L::Line,z)</code></pre><p>Find a parameter argument <code>t</code> such that <code>L(t)==z</code> is true. For an infinite <code>z</code>, return zero (but note that <code>L(1)</code> is also infinity).</p><p>This gives undefined results if <code>z</code> is not actually on the line. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Ray,Number}" href="#ComplexRegions.arg-Tuple{Ray,Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arg(R::Ray,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>R(t)==z</code> is true. </p><p>This gives undefined results if <code>z</code> is not actually on the ray. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.arg-Tuple{Segment,Number}" href="#ComplexRegions.arg-Tuple{Segment,Number}"><code>ComplexRegions.arg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arg(S::Segment,z)</code></pre><p>Find the parameter argument <code>t</code> such that <code>S(t)==z</code> is true. </p><p>This gives undefined results if <code>z</code> is not actually on the segment. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.between-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath},Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.between-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath},Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.between</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">between(outer,inner)</code></pre><p>Construct the region interior to the closed curve or path <code>outer</code> and interior to <code>inner</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,Arc}" href="#ComplexRegions.closest-Tuple{Number,Arc}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,A::Arc)</code></pre><p>Find the point on arc <code>A</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,Circle}" href="#ComplexRegions.closest-Tuple{Number,Circle}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,C::Circle)</code></pre><p>Find the point on circle <code>C</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,ComplexRegions.AbstractPath}" href="#ComplexRegions.closest-Tuple{Number,ComplexRegions.AbstractPath}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,P::AbstractPath)</code></pre><p>Find the point on the path <code>P</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,Line}" href="#ComplexRegions.closest-Tuple{Number,Line}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,L::Line)</code></pre><p>Find the point on line <code>L</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,Ray}" href="#ComplexRegions.closest-Tuple{Number,Ray}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,R::Ray)</code></pre><p>Find the point on ray <code>R</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.closest-Tuple{Number,Segment}" href="#ComplexRegions.closest-Tuple{Number,Segment}"><code>ComplexRegions.closest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">closest(z,S::Segment)</code></pre><p>Find the point on segment <code>S</code> that lies closest to <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.curve-Tuple{ComplexRegions.AbstractClosedPath,Integer}" href="#ComplexRegions.curve-Tuple{ComplexRegions.AbstractClosedPath,Integer}"><code>ComplexRegions.curve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">curve(P::AbstractClosedPath,k::Integer)</code></pre><p>Return the <code>k</code>th curve in the path <code>P</code>. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first curve. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.curve-Tuple{ComplexRegions.AbstractPath,Integer}" href="#ComplexRegions.curve-Tuple{ComplexRegions.AbstractPath,Integer}"><code>ComplexRegions.curve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">curve(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th curve in the path <code>P</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.curves-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.curves-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.curves</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">curves(P::AbstractPath)</code></pre><p>Return an array of the curves that make up the path <code>P</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.disk-Tuple{Circle}" href="#ComplexRegions.disk-Tuple{Circle}"><code>ComplexRegions.disk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">disk(C::Circle)</code></pre><p>Construct the disk interior to <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.disk-Tuple{Number,Real}" href="#ComplexRegions.disk-Tuple{Number,Real}"><code>ComplexRegions.disk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">disk(center::Number,radius::Real)</code></pre><p>Construct the disk with the given <code>center</code> and <code>radius</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,Arc}" href="#ComplexRegions.dist-Tuple{Number,Arc}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,A::Arc)</code></pre><p>Compute the distance from number <code>z</code> to the arc <code>A</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,Circle}" href="#ComplexRegions.dist-Tuple{Number,Circle}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,C::Circle)</code></pre><p>Compute the distance from number <code>z</code> to the circle <code>C</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,ComplexRegions.AbstractPath}" href="#ComplexRegions.dist-Tuple{Number,ComplexRegions.AbstractPath}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,P::AbstractPath)</code></pre><p>Find the distance from the path <code>P</code> to the point <code>z</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,Line}" href="#ComplexRegions.dist-Tuple{Number,Line}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,L::Line)</code></pre><p>Compute the distance from number <code>z</code> to the line <code>L</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,Ray}" href="#ComplexRegions.dist-Tuple{Number,Ray}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,R::Ray)</code></pre><p>Compute the distance from number <code>z</code> to the ray <code>R</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.dist-Tuple{Number,Segment}" href="#ComplexRegions.dist-Tuple{Number,Segment}"><code>ComplexRegions.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(z,S::Segment)</code></pre><p>Compute the distance from number <code>z</code> to the segment <code>S</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.exterior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.exterior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.exterior</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">exterior(C)</code></pre><p>Construct the region exterior to  the closed curve or path <code>C</code>. If <code>C</code> is bounded, the bounded enclosure is chosen regardless of the orientation of <code>C</code>; otherwise, the region &quot;to the right&quot; is the exterior. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.halfplane-Tuple{Line}" href="#ComplexRegions.halfplane-Tuple{Line}"><code>ComplexRegions.halfplane</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfplane(L::Line)</code></pre><p>Construct the half-plane to the left of <code>L</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.halfplane-Tuple{Number,Number}" href="#ComplexRegions.halfplane-Tuple{Number,Number}"><code>ComplexRegions.halfplane</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfplane(a,b)</code></pre><p>Construct the half-plane to the left of the line from <code>a</code> to <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.interior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.interior-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.interior</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">interior(C)</code></pre><p>Construct the region interior to the closed curve or path <code>C</code>. If <code>C</code> is bounded, the bounded enclosure is chosen regardless of the orientation of <code>C</code>; otherwise, the region &quot;to the left&quot; is the interior. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isinside-Tuple{Number,Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.isinside-Tuple{Number,Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.isinside</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isinside(X,z)</code></pre><p>Detect whether <code>z</code> lies inside the closed curve or path <code>X</code>. For a bounded path, this always means the bounded region enclosed by the curve, regardless of orientation; for an unbounded path, it means the region &quot;to the left&quot; as one walks along the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number,Line}" href="#ComplexRegions.isleft-Tuple{Number,Line}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isleft(z,L::Line)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of line <code>L</code>. This means that the angle it makes with <code>tangent(L)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the curve should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number,Ray}" href="#ComplexRegions.isleft-Tuple{Number,Ray}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isleft(z,R::Ray)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of ray <code>R</code>. This means that the angle it makes with <code>tangent(R)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) ray should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isleft-Tuple{Number,Segment}" href="#ComplexRegions.isleft-Tuple{Number,Segment}"><code>ComplexRegions.isleft</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isleft(z,S::Segment)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the left&quot; of segment <code>S</code>. This means that the angle it makes with <code>tangent(S)</code> is in the interval (0,π).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) segment should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isoutside-Tuple{Number,Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.isoutside-Tuple{Number,Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.isoutside</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isoutside(X,z)</code></pre><p>Detect whether <code>z</code> lies outside the closed curve or path <code>X</code>. For a bounded path, this always means the unbounded region complementary to the enclosure of the curve, regardless of orientation; for an unbounded path, it means the region &quot;to the right&quot; as one walks along the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ispositive-Tuple{CircularPolygon}" href="#ComplexRegions.ispositive-Tuple{CircularPolygon}"><code>ComplexRegions.ispositive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ispositive(p::CircularPolygon)</code></pre><p>Determine whether the circular polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.ispositive-Tuple{Polygon}" href="#ComplexRegions.ispositive-Tuple{Polygon}"><code>ComplexRegions.ispositive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ispositive(p::Polygon)</code></pre><p>Determine whether the polygon is positively oriented (i.e., circulates counterclockwise around the points it encloses).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number,Line}" href="#ComplexRegions.isright-Tuple{Number,Line}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isright(z,L::Line)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of line <code>L</code>. This means that the angle it makes with <code>tangent(L)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the curve should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number,Ray}" href="#ComplexRegions.isright-Tuple{Number,Ray}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isright(z,R::Ray)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of ray <code>R</code>. This means that the angle it makes with <code>tangent(R)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) ray should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.isright-Tuple{Number,Segment}" href="#ComplexRegions.isright-Tuple{Number,Segment}"><code>ComplexRegions.isright</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isright(z,S::Segment)</code></pre><p>Determine whether the number <code>z</code> lies &quot;to the right&quot; of segment <code>S</code>. This means that the angle it makes with <code>tangent(S)</code> is in the interval (-π,0).</p><p>Note that <code>isleft</code> and <code>isright</code> are <em>not</em> logical opposites; a point on the (extended) segment should give <code>false</code> in both cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.n_gon-Tuple{Integer}" href="#ComplexRegions.n_gon-Tuple{Integer}"><code>ComplexRegions.n_gon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">n_gon(n)</code></pre><p>Construct a regular n-gon with vertices on the unit circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.normal-Tuple{ComplexRegions.AbstractCurve,Real}" href="#ComplexRegions.normal-Tuple{ComplexRegions.AbstractCurve,Real}"><code>ComplexRegions.normal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">normal(C::AbstractCurve,t::Real)</code></pre><p>Find the unit complex number in the direction of the leftward-pointing normal to curve <code>C</code> at parameter value <code>t</code> in [0,1]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.normal-Tuple{ComplexRegions.AbstractPath,Real}" href="#ComplexRegions.normal-Tuple{ComplexRegions.AbstractPath,Real}"><code>ComplexRegions.normal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">normal(P::AbstractPath,t::Real)</code></pre><p>Compute a complex-valued normal to path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.plotdata-Tuple{ComplexRegions.AbstractCurve}" href="#ComplexRegions.plotdata-Tuple{ComplexRegions.AbstractCurve}"><code>ComplexRegions.plotdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plotdata(C::AbstractCurve,n=501)</code></pre><p>Compute <code>n</code> points along the curve <code>C</code> suitable to make a plot of it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.point-Tuple{ComplexRegions.AbstractCurve,Real}" href="#ComplexRegions.point-Tuple{ComplexRegions.AbstractCurve,Real}"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">point(C::AbstractCurve,t::Real)</code></pre><p>Find the point on curve <code>C</code> at parameter value <code>t</code>, which should lie in the interval [0,1]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractCurve,AbstractArray{T,N} where N}} where T&lt;:Real" href="#ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractCurve,AbstractArray{T,N} where N}} where T&lt;:Real"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">point(C::AbstractCurve,t::AbstractArray)</code></pre><p>Vectorize the <code>point</code> function for curve <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath,AbstractArray{T,N} where N}} where T&lt;:Real" href="#ComplexRegions.point-Union{Tuple{T}, Tuple{ComplexRegions.AbstractPath,AbstractArray{T,N} where N}} where T&lt;:Real"><code>ComplexRegions.point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">point(P::AbstractPath,t::Real)
P(t)</code></pre><p>Compute the point along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. </p><pre><code class="language-none">point(P::AbstractPath,t::AbstractVector)</code></pre><p>Vectorize the <code>point</code> method for path <code>P</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.rectangle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#ComplexRegions.rectangle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>ComplexRegions.rectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rectangle(xlim,ylim)</code></pre><p>Construct the rectangle defined by <code>xlim[1]</code><code>&lt; x &lt;</code>xlim[2]<code>,</code>ylim[1]`<code>&lt; y &lt;</code>ylim[2]`, where z=complex(x,y).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.rectangle-Tuple{Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat,Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat}" href="#ComplexRegions.rectangle-Tuple{Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat,Union{Complex{S}, Polar{S}, Spherical{S}} where S&lt;:AbstractFloat}"><code>ComplexRegions.rectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rectangle(z1,z2)</code></pre><p>Construct the rectangle whose opposing corners are the given complex values. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number,Circle}" href="#ComplexRegions.reflect-Tuple{Number,Circle}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reflect(z,C::Circle)</code></pre><p>Reflect the value <code>z</code> across the circle <code>C</code>. (For reflection of a circle through a point, use translation and negation.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number,Line}" href="#ComplexRegions.reflect-Tuple{Number,Line}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reflect(z,L::Line)</code></pre><p>Reflect the value <code>z</code> across the line <code>L</code>. (For reflection of a line through a point, use translation and negation.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.reflect-Tuple{Number,Segment}" href="#ComplexRegions.reflect-Tuple{Number,Segment}"><code>ComplexRegions.reflect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reflect(z,S::Segment)</code></pre><p>Reflect the value <code>z</code> across the extension of segment <code>S</code> to a line. (For reflection of a segment through a point, use translation and negation.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.tangent-Tuple{ComplexRegions.AbstractCurve,Real}" href="#ComplexRegions.tangent-Tuple{ComplexRegions.AbstractCurve,Real}"><code>ComplexRegions.tangent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tangent(C::AbstractCurve,t::Real)</code></pre><p>Find the complex number representing the tangent to curve <code>C</code> at parameter value <code>t</code> in [0,1]. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.tangent-Tuple{ComplexRegions.AbstractPath,Real}" href="#ComplexRegions.tangent-Tuple{ComplexRegions.AbstractPath,Real}"><code>ComplexRegions.tangent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tangent(P::AbstractPath,t::Real)</code></pre><p>Compute the complex-valued tangent along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractCurve,Real}" href="#ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractCurve,Real}"><code>ComplexRegions.unittangent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unittangent(C::AbstractCurve,t::Real)</code></pre><p>Find the complex number representing the unit tangent to curve <code>C</code> at parameter value <code>t</code> in [0,1]. For Lines, Segments, and Rays, the <code>t</code> argument is optional.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractPath,Real}" href="#ComplexRegions.unittangent-Tuple{ComplexRegions.AbstractPath,Real}"><code>ComplexRegions.unittangent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unittangent(P::AbstractPath,t::Real)</code></pre><p>Compute the complex-valued unit tangent along path <code>P</code> at parameter value <code>t</code>. Values of <code>t</code> in [k,k+1] correspond to values in [0,1] along curve k of the path, for k = 1,2,...,length(P)-1. The result is not well-defined at an integer value of <code>t</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.vertex-Tuple{ComplexRegions.AbstractClosedPath,Integer}" href="#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractClosedPath,Integer}"><code>ComplexRegions.vertex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertex(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th vertex of the path <code>P</code>. The index is applied circularly; e.g, if the closed path has n curves, then ...,1-n,1,1+n,... all refer to the first vertex. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.vertex-Tuple{ComplexRegions.AbstractPath,Integer}" href="#ComplexRegions.vertex-Tuple{ComplexRegions.AbstractPath,Integer}"><code>ComplexRegions.vertex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertex(P::AbstractPath,k::Integer)</code></pre><p>Return the <code>k</code>th vertex of the path <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.vertices-Tuple{ComplexRegions.AbstractClosedPath}" href="#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractClosedPath}"><code>ComplexRegions.vertices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices(P::AbstractClosedPath)</code></pre><p>Return an array of the unique vertices (endpoints of the curves) of the closed path <code>P</code>. The length is equal the number of curves in <code>P</code>, i.e., the first/last vertex is not duplicated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.vertices-Tuple{ComplexRegions.AbstractPath}" href="#ComplexRegions.vertices-Tuple{ComplexRegions.AbstractPath}"><code>ComplexRegions.vertices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices(P::AbstractPath)</code></pre><p>Return an array of the vertices (endpoints of the curves) of the path <code>P</code>. The length is one greater than the number of curves in <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.winding-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}" href="#ComplexRegions.winding-Tuple{Union{ComplexRegions.AbstractClosedCurve, ComplexRegions.AbstractClosedPath}}"><code>ComplexRegions.winding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">winding(P,z)</code></pre><p>Compute the winding number of a closed curve or path <code>P</code> about the point <code>z</code>. Each counterclockwise rotation about <code>z</code> contributes +1, and each clockwise rotation about it counts -1. The winding number is zero for points not in the region enclosed by <code>P</code>. </p><p>The result is unreliable for points lying on <code>P</code>, for which the problem is ill-posed.</p></div></div></section><h2><a class="nav-anchor" id="Other-functions-1" href="#Other-functions-1">Other functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ComplexRegions.default-Tuple{}" href="#ComplexRegions.default-Tuple{}"><code>ComplexRegions.default</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ComplexRegions.default()</code></pre><p>Return a dictionary of global default settings for the ComplexRegions package.</p><pre><code class="language-none">ComplexRegions.default(key=value)</code></pre><p>Change a global default setting in the running instance of the ComplexRegions package.</p></div></div></section><footer><hr/><a class="previous" href="../mobius/"><span class="direction">Previous</span><span class="title">Möbius</span></a></footer></article></body></html>
