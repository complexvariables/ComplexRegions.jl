<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polygons · ComplexRegions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ComplexRegions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../curves/">Curves</a></li><li><a class="toctext" href="../paths/">Paths</a></li><li class="current"><a class="toctext" href>Polygons</a><ul class="internal"><li><a class="toctext" href="#CircularPolygon-1">CircularPolygon</a></li><li><a class="toctext" href="#Polygon-1">Polygon</a></li><li class="toplevel"><a class="toctext" href="#examples_polygons-1">Examples</a></li></ul></li><li><a class="toctext" href="../intersections/">Intersections</a></li><li><a class="toctext" href="../regions/">Regions</a></li><li><a class="toctext" href="../mobius/">Möbius</a></li><li><a class="toctext" href="../api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Polygons</a></li></ul><a class="edit-page" href="https://github.com//blob/master/docs/src/polygons.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Polygons</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h1><p>There are two specialized implementations of the <code>AbstractClosedPath</code> type: <code>CircularPolygon</code> and the subtype <code>Polygon</code>, which implement the <code>AbstractCircularPolygon</code> and <code>AbstractPolygon</code> types, respectively.</p><h2><a class="nav-anchor" id="CircularPolygon-1" href="#CircularPolygon-1">CircularPolygon</a></h2><p>A <code>CircularPolygon</code> is a closed path whose curve components are all of type <code>Arc</code>, <code>Ray</code>, and <code>Segment</code>. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling <code>CircularPolygon(c)</code> with a vector or <code>AbstractPath</code> of curves of appropriate types; continuity and closure of the path are checked as necessary.</p><p>In addition to the usual methods for a <code>ClosedPath</code>, the following are implemented:</p><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>side</code></td><td style="text-align: left">Alias for <code>curve</code>.</td></tr><tr><td style="text-align: left"><code>winding(P,z)</code></td><td style="text-align: left">Winding number of <code>P</code> relative to <code>z</code>.</td></tr><tr><td style="text-align: left"><code>truncate(P)</code></td><td style="text-align: left">Replace infinite sides with finite ones.</td></tr></table><h2><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h2><p>A <code>Polygon</code> is a closed path whose curve components are all of type <code>Ray</code> and <code>Segment</code>. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling <code>Polygon(c)</code> with a vector or <code>AbstractPath</code> of curves of appropriate types; continuity and closure of the path are checked as necessary.</p><p>An alternative construction is to provide a vector of vertices. In place of an infinite vertex, you can supply a tuple of the angles of the two rays that meet there. See the <a href="#examples_polygons-1">Examples</a> below.</p><p>In addition to the methods for the <a href="../paths/#interface_paths-1">Abstract interface</a> and <a href="#CircularPolygon-1">CircularPolygon</a>, the <code>Polygon</code> type offers</p><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>angles(P)</code></td><td style="text-align: left">Interior angles of the polygon.</td></tr></table><p>Angles at a finite vertex are in the interval <span>$(0,2\pi]$</span>, while angles at an infinite vertex are in <span>$[-2\pi,0]$</span>, representing the angle at the pole of the Riemann sphere.</p><p>Two additional special polygon constructors are defined:</p><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>rectangle(xlim,ylim)</code> or <code>rectangle(z1,z2)</code></td><td style="text-align: left">Construct an axes-aligned rectangle.</td></tr><tr><td style="text-align: left"><code>n_gon(n)</code></td><td style="text-align: left">Construct a regular n-gon with unit vertices.</td></tr></table><h1><a class="nav-anchor" id="examples_polygons-1" href="#examples_polygons-1">Examples</a></h1><div></div><p>A big plus:</p><pre><code class="language-julia">box = [1-1im,3-1im,3+1im];
plus = Polygon([box;1im*box;-box;-1im*box])
plot(plus,color=:red)</code></pre><p><img src="../plus.svg" alt="plus polygon"/></p><p>A Koch snowflake:</p><pre><code class="language-julia">v = vertices(n_gon(3));
pattern = [1; (v.-v[1])/(v[1]-v[3])/3 .+ 2/3 ];
koch(a,b) = b .+ (a-b)*pattern;
for m = 1:3
	@show n = length(v);
	global v = vcat( [koch(v[k],v[mod(k,n)+1]) for k in 1:n]... );
end
plot(Polygon(v))</code></pre><pre><code class="language-none">n = length(v) = 3
n = length(v) = 12
n = length(v) = 48</code></pre><p><img src="../snowflake.svg" alt="snowflake polygon"/></p><p>Infinite channel with a step:</p><pre><code class="language-julia">p = Polygon([0,-1im,(0,0),1im,(pi,pi)])</code></pre><pre><code class="language-none">Polygon with 5 vertices:
   0.0 + 0.0im, interior angle 1.5⋅π
   0.0 - 1.0im, interior angle 0.5⋅π
   Inf + 0.0im, interior angle 0.0⋅π
   0.0 + 1.0im, interior angle 1.0⋅π
   Inf + 0.0im, interior angle 0.0⋅π</code></pre><pre><code class="language-julia">plot(p)</code></pre><p><img src="../channel.svg" alt="channel polygon"/></p><p>Infinite polygons can seem quite strange sometimes:</p><pre><code class="language-julia">probe1 = [1,0,1im,-1im,0];
probe2 = exp(-1im*3π/4)*probe1 .- (3 + 2im);
p = Polygon([probe1...,(0,-3π/4),probe2...,(-3π/4,0)])</code></pre><p><img src="../probes.svg" alt="probes polygon"/></p><footer><hr/><a class="previous" href="../paths/"><span class="direction">Previous</span><span class="title">Paths</span></a><a class="next" href="../intersections/"><span class="direction">Next</span><span class="title">Intersections</span></a></footer></article></body></html>
